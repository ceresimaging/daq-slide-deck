<div class="slide">
    <h1>When Zero Isn't Special: Arbitrary Wrap Points</h1>
    
    <div class="warning-box">
        <h3>ğŸ¯ Real Hardware Doesn't Care About Zero</h3>
        <p>Many circular quantities in the wild wrap at arbitrary values, not nice round numbers. The math still worksâ€”you just need to normalize first!</p>
    </div>
    
    <div class="two-column-equal">
        <div class="card">
            <h3>ğŸ“Š Common Non-Zero Wrap Domains</h3>
            <div class="example-list">
                <div class="example-item">
                    <h4>ğŸ§­ Compass: [-180Â°, +180Â°)</h4>
                    <p>Wraps at Â±180Â°, not 0Â°/360Â°</p>
                    <code>bearing âˆˆ [-180, 180)</code>
                </div>
                <div class="example-item">
                    <h4>ğŸ”§ Rotary Encoder: [1000, 5096)</h4>
                    <p>12-bit encoder with arbitrary offset</p>
                    <code>counts âˆˆ [1000, 5096)</code>
                </div>
                <div class="example-item">
                    <h4>ğŸ“¡ Phase: [-Ï€, +Ï€)</h4>
                    <p>Centered around zero, not starting at it</p>
                    <code>phase âˆˆ [-Ï€, Ï€)</code>
                </div>
                <div class="example-item">
                    <h4>ğŸ—“ï¸ Fiscal Year: [Apr, Mar]</h4>
                    <p>Wraps at March/April boundary</p>
                    <code>month âˆˆ [4, 3] (mod 12)</code>
                </div>
                <div class="example-item">
                    <h4>ğŸŒ¡ï¸ ADC Values: [512, 3584)</h4>
                    <p>Sensor with DC offset and limited range</p>
                    <code>adc âˆˆ [512, 3584)</code>
                </div>
            </div>
        </div>
        
        <div class="card">
            <h3>âœ¨ The Universal Transform</h3>
            <div class="formula-showcase" style="background: rgba(76, 175, 80, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                <h4>For any circular quantity:</h4>
                <p><code>value âˆˆ [min, max)</code></p>
                <p style="margin: 15px 0;">â†“</p>
                <p><strong>1. Normalize to [0, 1):</strong></p>
                <p><code>t = (value - min) / (max - min)</code></p>
                <p style="margin: 15px 0;">â†“</p>
                <p><strong>2. Embed on unit circle:</strong></p>
                <p><code>v = (cos(2Ï€t), sin(2Ï€t))</code></p>
                <p style="margin: 15px 0;">â†“</p>
                <p><strong>3. Do your math in â„Â²</strong></p>
                <p style="margin: 15px 0;">â†“</p>
                <p><strong>4. Project back if needed:</strong></p>
                <p><code>result = min + (max-min) Ã— atan2(v.y, v.x)/(2Ï€)</code></p>
            </div>
        </div>
    </div>
    
    <div class="success-box">
        <h3>ğŸ’» Code Example: Averaging Compass Bearings</h3>
        <div class="code-example">
            <pre><code class="language-python"># PROBLEM: Compass uses [-180Â°, +180Â°) not [0Â°, 360Â°)
bearings = [170, 175, -175, -170]  # All pointing roughly south

# WRONG: Simple average
naive_mean = np.mean(bearings)  # = 0Â° (North!) ğŸ¤¦

# RIGHT: Normalize â†’ Embed â†’ Average â†’ Denormalize
def circular_mean(values, min_val, max_val):
    # Step 1: Normalize to [0, 1)
    period = max_val - min_val
    normalized = [(v - min_val) / period for v in values]
    
    # Step 2: Embed on circle
    vectors = [(np.cos(2*np.pi*t), np.sin(2*np.pi*t)) for t in normalized]
    
    # Step 3: Average in vector space
    mean_vector = np.mean(vectors, axis=0)
    
    # Step 4: Project back to original domain
    angle = np.atan2(mean_vector[1], mean_vector[0])
    result = min_val + (angle / (2*np.pi)) * period
    if result < min_val:
        result += period
    return result

correct_mean = circular_mean(bearings, -180, 180)  # â‰ˆ 175Â° South! âœ…</code></pre>
        </div>
    </div>
    
    <div class="info-box">
        <h3>ğŸ”§ Practical Examples</h3>
        <div class="three-column">
            <div>
                <h4>ğŸ® Game Development</h4>
                <div class="code-snippet">
                    <pre><code># Joystick angle âˆˆ [-Ï€, Ï€]
js_angle = atan2(js.y, js.x)
# Don't compare directly!
# Normalize first</code></pre>
                </div>
            </div>
            <div>
                <h4>ğŸ¤– Robotics</h4>
                <div class="code-snippet">
                    <pre><code># Encoder wraps at 8192
# but starts at 1000
actual_pos = 1000 + 
  (raw - 1000) % 7192</code></pre>
                </div>
            </div>
            <div>
                <h4>ğŸ“Š Time Series</h4>
                <div class="code-snippet">
                    <pre><code># Fiscal quarters Q2-Q1
# April = month 0
fiscal_month = 
  (cal_month - 4) % 12</code></pre>
                </div>
            </div>
        </div>
    </div>
    
    <div class="highlight-box">
        <h3>ğŸ¯ Key Insight</h3>
        <p style="font-size: 18px; text-align: center; margin: 20px 0;">
            <strong>The "zero point" is arbitrary!</strong> What matters is the <em>topology</em>â€”that values wrap around.
        </p>
        <p style="text-align: center;">
            Always normalize to [0, 1) or [0, 2Ï€) before embedding. Your vector math doesn't care where the original wrap point was.
        </p>
    </div>
</div>