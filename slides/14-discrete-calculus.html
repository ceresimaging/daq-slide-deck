<div class="slide">
    <h1>Discrete Calculus on Circles: Data-Driven Operations</h1>
    
    <div class="info-box">
        <h3>ğŸ“Š Real-World Data = Discrete Samples</h3>
        <p>In practice, we don't have continuous functionsâ€”we have <strong>time series data</strong> of circular quantities. How do we compute derivatives and integrals when our data wraps around?</p>
    </div>
    
    <div class="two-column-equal">
        <div class="card">
            <h3>ğŸ“ˆ Discrete Derivatives (Angular Velocity)</h3>
            <div class="code-example">
                <pre><code class="language-python"># WRONG: Naive difference breaks at wraparound
angles = [358Â°, 359Â°, 1Â°, 2Â°]  # Smooth rotation
naive_diff = [1Â°, 2Â°, -357Â°]  # HUGE SPIKE! ğŸ’¥

# RIGHT: Vector space derivative
vectors = [(cos(Î¸), sin(Î¸)) for Î¸ in angles]
dvdt = [(v[i+1] - v[i])/dt for i in range(len(v)-1)]

# Angular velocity from vector derivative
Ï‰ = cross_product(v[i], dvdt[i]) / |v[i]|Â²
# Result: [1Â°/s, 1Â°/s, 1Â°/s] âœ…</code></pre>
            </div>
        </div>
        
        <div class="card">
            <h3>ğŸ“‰ Discrete Integrals (Accumulated Rotation)</h3>
            <div class="code-example">
                <pre><code class="language-python"># WRONG: Sum angles directly
angular_velocities = [90Â°/s, 90Â°/s, 90Â°/s, 90Â°/s]
naive_sum = sum(angular_velocities) * dt  # 360Â°???

# RIGHT: Accumulate in vector space
v_accumulated = [1, 0]  # Start at 0Â°
for Ï‰ in angular_velocities:
    # Rotate vector by angular increment
    dÎ¸ = Ï‰ * dt
    rotation = [[cos(dÎ¸), -sin(dÎ¸)],
                [sin(dÎ¸), cos(dÎ¸)]]
    v_accumulated = rotation @ v_accumulated

final_angle = atan2(v_accumulated)  # Correct!</code></pre>
            </div>
        </div>
    </div>
    
    <div class="success-box">
        <h3>ğŸ”§ Practical Applications in Data Science</h3>
        <div class="two-column">
            <div>
                <h4>ğŸŒŠ Wind Speed Analysis</h4>
                <div class="code-example">
                    <pre><code class="language-python"># Wind direction time series (sampled every hour)
wind_dirs = [350Â°, 355Â°, 0Â°, 5Â°, 10Â°]  # North-ish
wind_speeds = [10, 12, 15, 14, 11]  # mph

# Compute wind vector components
u = [-speed * sin(dir) for speed, dir in zip(wind_speeds, wind_dirs)]
v = [-speed * cos(dir) for speed, dir in zip(wind_speeds, wind_dirs)]

# Now can compute proper derivatives!
du_dt = np.gradient(u)  # Wind acceleration (east)
dv_dt = np.gradient(v)  # Wind acceleration (north)</code></pre>
                </div>
            </div>
            <div>
                <h4>ğŸ¤– Robot Heading Tracking</h4>
                <div class="code-example">
                    <pre><code class="language-python"># IMU gives heading samples at 100Hz
headings = sensor.get_heading_buffer()  # [Î¸â‚, Î¸â‚‚, ..., Î¸â‚™]
dt = 0.01  # 10ms between samples

# Convert to unit vectors
vectors = [(cos(h), sin(h)) for h in headings]

# Compute angular velocity using discrete derivative
angular_vel = []
for i in range(len(vectors)-1):
    # Cross product gives rotation rate
    Ï‰ = (vectors[i][0]*vectors[i+1][1] - 
         vectors[i][1]*vectors[i+1][0]) / dt
    angular_vel.append(Ï‰)

# Smooth using windowed average (no wraparound issues!)
smoothed_Ï‰ = moving_average(angular_vel, window=10)</code></pre>
                </div>
            </div>
        </div>
    </div>
    
    <div class="warning-box">
        <h3>âš ï¸ Common Pitfalls with Discrete Circular Data</h3>
        <div class="three-column">
            <div>
                <h4>âŒ Phase Unwrapping</h4>
                <p><code>unwrap([350Â°, 10Â°])</code> â†’ <code>[350Â°, 370Â°]</code></p>
                <p>Creates artificial trends! Use vectors instead.</p>
            </div>
            <div>
                <h4>âŒ Modulo Arithmetic</h4>
                <p><code>(Î¸â‚‚ - Î¸â‚) % 360</code></p>
                <p>Loses direction info. Vector difference preserves it.</p>
            </div>
            <div>
                <h4>âŒ Averaging Raw Angles</h4>
                <p><code>mean([0Â°, 90Â°, 180Â°, 270Â°])</code> â†’ <code>135Â°</code></p>
                <p>Should be undefined! Vector mean â†’ 0.</p>
            </div>
        </div>
    </div>
    
    <div class="highlight-box">
        <h3>ğŸ¯ The Key Pattern for Discrete Operations</h3>
        <div class="formula-showcase">
            <div style="text-align: center; padding: 20px;">
                <p style="font-size: 18px; margin: 10px 0;">
                    <strong>Discrete Samples</strong> â†’ <strong>Vector Time Series</strong> â†’ <strong>Standard Numpy Operations</strong> â†’ <strong>Interpret Results</strong>
                </p>
                <p style="margin-top: 20px;">
                    <code>Î¸[t]</code> â†’ <code>[cos(Î¸[t]), sin(Î¸[t])]</code> â†’ <code>np.gradient(), np.cumsum()</code> â†’ <code>atan2() if needed</code>
                </p>
            </div>
        </div>
        <p><strong>Bottom Line:</strong> NumPy/Pandas operations "just work" on vector representationsâ€”no special circular functions needed!</p>
    </div>
</div>