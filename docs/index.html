<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stop Fighting Wraparound: Embed Your Rings!</title>

    <!-- Code syntax highlighting with Highlight.js -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">

    <!-- Leaflet CSS for GIS demo -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="">

    <!-- D3 UMD (exposes window.d3) -->
    <script src="https://d3js.org/d3.v7.min.js" defer></script>

    <!-- D3FC UMD bundle (exposes window.fc, includes label-layout) -->
    <script src="https://unpkg.com/d3fc@15" defer></script>

    <style>
:root {
  /* Updated with Ceres logo color palette */
  --bg: #0a1a1f;
  --card: #10161d;
  --ink: #dbe2eb;
  --muted: #9fb0c6;
  --accent: #22d3ee; /* Cyan from logo */
  --accent2: #4ade80; /* Green from logo */
  --accent3: #ff7b7b;
  --warning: #ffb86c;
  --ceres-dark: #0a1a1f;
  --ceres-green: #4ade80;
  --ceres-cyan: #22d3ee;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html,
body {
  height: 100%;
  margin: 0;
  background: radial-gradient(
    1000px 800px at 70% 10%,
    #0e1420 0%,
    var(--bg) 60%
  );
  color: var(--ink);
  font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto,
    Inter, "Helvetica Neue", Arial, sans-serif;
  line-height: 1.35;
}

.slideshow-container {
  position: relative;
  width: 100%;
  height: 100vh;
  display: grid;
  grid-template-rows: 1fr auto;
}

#slide-content {
  padding: 56px 64px;
  background: radial-gradient(
      600px 400px at 10% 5%,
      rgba(112, 181, 255, 0.06),
      transparent 50%
    ),
    radial-gradient(
      700px 500px at 90% 0%,
      rgba(155, 255, 176, 0.05),
      transparent 60%
    );
  border-radius: 12px;
  margin: 20px;
  height: calc(100vh - 80px);
  overflow-y: auto;
  animation: fadeIn 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
  border: 1px solid rgba(255, 255, 255, 0.08);
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

h1 {
  font-size: 54px;
  font-weight: 750;
  letter-spacing: -0.02em;
  line-height: 1.1;
  color: var(--ink);
  margin-bottom: 30px;
  text-align: center;
}

h2 {
  font-size: 36px;
  font-weight: 700;
  letter-spacing: -0.01em;
  line-height: 1.1;
  color: var(--ink);
  margin: 30px 0 20px 0;
  border-left: 4px solid var(--accent);
  padding-left: 20px;
}

h3 {
  font-size: 22px;
  font-weight: 650;
  color: var(--muted);
  margin: 20px 0 15px 0;
}

h4 {
  font-size: 18px;
  font-weight: 600;
  color: var(--ink);
  margin: 15px 0 10px 0;
}

p,
li {
  font-size: 20px;
  color: #c9d6e5;
  line-height: 1.5;
}

.subtitle {
  text-align: center;
  color: var(--muted);
  font-size: 22px;
  margin-bottom: 40px;
}

.two-column {
  display: grid;
  grid-template-columns: 1.1fr 1fr;
  gap: 26px;
  align-items: start;
  margin: 30px 0;
}

.two-column-equal {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 26px;
  align-items: start;
  margin: 30px 0;
}

.two-column-equal img {
  width: 100%;
  height: auto;
  object-fit: contain;
}

.three-column {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 26px;
  margin: 30px 0;
}

.card,
.highlight-box,
.success-box,
.warning-box,
.info-box {
  background: linear-gradient(
    180deg,
    rgba(255, 255, 255, 0.04),
    rgba(255, 255, 255, 0.02)
  );
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 16px;
  padding: 18px 20px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
  margin: 20px 0;
}

.highlight-box {
  border-left: 4px solid var(--accent3);
  background: linear-gradient(
    180deg,
    rgba(255, 123, 123, 0.08),
    rgba(255, 123, 123, 0.04)
  );
}

.success-box {
  border-left: 4px solid var(--accent2);
  background: linear-gradient(
    180deg,
    rgba(155, 255, 176, 0.08),
    rgba(155, 255, 176, 0.04)
  );
}

.warning-box {
  border-left: 4px solid var(--warning);
  background: linear-gradient(
    180deg,
    rgba(255, 184, 108, 0.08),
    rgba(255, 184, 108, 0.04)
  );
}

.info-box {
  border-left: 4px solid var(--accent);
  background: linear-gradient(
    180deg,
    rgba(112, 181, 255, 0.08),
    rgba(112, 181, 255, 0.04)
  );
}

ul,
ol {
  margin: 15px 0;
  padding-left: 30px;
}

ul.compact li {
  margin-bottom: 8px;
}

li {
  margin: 8px 0;
}

.metric {
  background: rgba(255, 255, 255, 0.04);
  border: 1px solid rgba(255, 255, 255, 0.07);
  padding: 16px;
  border-radius: 14px;
  margin: 10px 0;
  text-align: center;
}

.metric-value {
  font-size: 36px;
  font-weight: 800;
  color: var(--accent);
}

.metric-label {
  color: var(--muted);
  font-size: 14px;
  margin-top: 4px;
  letter-spacing: 0.06em;
  text-transform: uppercase;
}

.code-block {
  background: rgba(0, 0, 0, 0.4);
  color: var(--ink);
  padding: 20px;
  border-radius: 12px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
    "Liberation Mono", monospace;
  font-size: 16px;
  margin: 15px 0;
  overflow-x: auto;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.navigation {
  position: fixed;
  bottom: 30px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 1000;
  display: flex;
  gap: 8px;
}

.nav-button {
  background: rgba(255, 255, 255, 0.06);
  color: var(--ink);
  border: 1px solid rgba(255, 255, 255, 0.12);
  border-radius: 10px;
  padding: 8px 12px;
  cursor: pointer;
  font-weight: 600;
  font-size: 1em;
  transition: all 0.3s;
}

.nav-button:hover {
  background: rgba(255, 255, 255, 0.12);
  transform: translateY(-2px);
}

.nav-button:disabled {
  background: rgba(255, 255, 255, 0.03);
  color: var(--muted);
  cursor: not-allowed;
  transform: none;
}

.nav-button:focus {
  outline: 2px solid var(--accent);
  outline-offset: 2px;
}

.slide-counter {
  position: fixed;
  bottom: 30px;
  right: 30px;
  background: rgba(0, 0, 0, 0.5);
  color: var(--ink);
  padding: 10px 15px;
  border-radius: 20px;
  font-size: 14px;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.status-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 20px;
  margin: 20px 0;
}

.status-item {
  background: linear-gradient(
    180deg,
    rgba(255, 255, 255, 0.04),
    rgba(255, 255, 255, 0.02)
  );
  border: 2px solid rgba(255, 255, 255, 0.08);
  border-radius: 16px;
  padding: 20px;
  text-align: center;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
}

.status-item.completed {
  border-color: var(--accent2);
  background: linear-gradient(
    180deg,
    rgba(155, 255, 176, 0.08),
    rgba(155, 255, 176, 0.04)
  );
}

.status-item.in-progress {
  border-color: var(--warning);
  background: linear-gradient(
    180deg,
    rgba(255, 184, 108, 0.08),
    rgba(255, 184, 108, 0.04)
  );
}

.status-item.critical {
  border-color: var(--accent3);
  background: linear-gradient(
    180deg,
    rgba(255, 123, 123, 0.08),
    rgba(255, 123, 123, 0.04)
  );
}

.timeline {
  position: relative;
  margin: 30px 0;
}

.timeline-item {
  margin: 20px 0;
  padding-left: 40px;
  position: relative;
}

.timeline-item::before {
  content: "";
  position: absolute;
  left: 15px;
  top: 8px;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: var(--accent);
}

.timeline-item::after {
  content: "";
  position: absolute;
  left: 20px;
  top: 20px;
  width: 2px;
  height: calc(100% + 10px);
  background: rgba(255, 255, 255, 0.1);
}

.timeline-item:last-child::after {
  display: none;
}

.process-flow {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin: 30px 0;
  flex-wrap: wrap;
}

.process-step {
  background: rgba(255, 255, 255, 0.04);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 16px;
  padding: 20px;
  margin: 10px;
  text-align: center;
  flex: 1;
  min-width: 200px;
  position: relative;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

.process-step::after {
  content: "‚Üí";
  position: absolute;
  right: -25px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 2em;
  color: var(--accent);
}

.process-step:last-child::after {
  display: none;
}

.mask-example {
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  gap: 20px;
  margin: 20px 0;
  align-items: center;
}

.mask-box {
  background: rgba(255, 255, 255, 0.04);
  border: 1px solid rgba(255, 255, 255, 0.08);
  padding: 20px;
  border-radius: 12px;
  text-align: center;
}

.operation {
  font-size: 2em;
  color: var(--accent);
  font-weight: bold;
}

.badge {
  padding: 3px 8px;
  border-radius: 999px;
  font-size: 12px;
  color: #0a1422;
  background: linear-gradient(90deg, var(--accent), var(--accent2));
  font-weight: 700;
  display: inline-block;
}

.mono {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
    "Liberation Mono", monospace;
  font-size: 16px;
}

.kpi {
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 16px;
}

.kpi .stat {
  text-align: center;
  padding: 16px;
  border-radius: 14px;
  background: rgba(255, 255, 255, 0.04);
  border: 1px solid rgba(255, 255, 255, 0.07);
}

.kpi .num {
  font-size: 36px;
  font-weight: 800;
  color: var(--accent);
}

.kpi .label {
  font-size: 14px;
  color: var(--muted);
  margin-top: 4px;
  letter-spacing: 0.06em;
  text-transform: uppercase;
}

/* Operation list styles for slide 4 */
.operation-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin: 15px 0;
}

.op-item {
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.06);
  border-radius: 8px;
  padding: 12px 16px;
  transition: all 0.2s ease;
}

.op-item:hover {
  background: rgba(255, 255, 255, 0.04);
  border-color: rgba(255, 255, 255, 0.12);
}

.op-item strong {
  color: var(--accent);
  font-weight: 650;
}

.op-item small {
  color: var(--muted);
  font-size: 14px;
  margin-top: 4px;
  display: block;
}

.code-example {
  background: rgba(0, 0, 0, 0.3);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 12px;
  padding: 20px;
  margin: 15px 0;
}

.formula-showcase {
  text-align: center;
  background: rgba(255, 255, 255, 0.02);
  padding: 16px;
  border-radius: 10px;
  margin: 15px 0;
  border: 1px solid rgba(255, 255, 255, 0.06);
}

.formula-showcase code {
  font-size: 18px;
  font-weight: 600;
  color: var(--accent);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
    "Liberation Mono", monospace;
}

/* Scrollbar styling for dark theme */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: rgba(255, 255, 255, 0.05);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.2);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.3);
}

/* Title slide specific styles */
.title-slide {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 100vh;
  background: linear-gradient(135deg, var(--ceres-dark) 0%, #1a2f33 100%);
  color: white;
  padding: 2em;
  position: relative;
}

.logo-container {
  margin-bottom: 2em;
  animation: fadeInScale 0.8s ease-out;
}

.title-logo {
  width: 200px;
  height: auto;
  filter: drop-shadow(0 10px 30px rgba(34, 211, 238, 0.3));
}

@keyframes fadeInScale {
  from {
    opacity: 0;
    transform: scale(0.9);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}

.main-title {
  font-size: 3.5em;
  margin-bottom: 0.2em;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
  background: linear-gradient(90deg, var(--ceres-green), var(--ceres-cyan));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.visual-element {
  margin: 2em 0;
}

.presenter-info {
  margin-top: 2em;
  text-align: center;
}

.presenter-info p {
  margin: 0.5em 0;
  font-size: 1.2em;
}

.company-branding {
  margin: 1em 0;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.1em;
}

.Ceres-logo {
  font-size: 2.2em;
  font-weight: 700;
  color: #4caf50;
  letter-spacing: 0.05em;
  text-shadow: 0 2px 4px rgba(76, 175, 80, 0.3);
}

.Ceres-ai {
  font-size: 2.2em;
  font-weight: 300;
  color: #70b5ff;
  letter-spacing: 0.05em;
  text-shadow: 0 2px 4px rgba(112, 181, 255, 0.3);
}

.presenter-info .date {
  font-size: 2em;
  font-weight: 300;
  margin-bottom: 1em;
}

/* Common visual demo styles */
.visual-demo {
  display: flex;
  justify-content: center;
  margin: 2em 0;
}

.code-comparison {
  display: flex;
  gap: 1em;
  margin: 1em 0;
}

.clock-visual {
  margin: 2em 0;
  display: flex;
  justify-content: center;
}

/* Interactive demo styles */
.demo-container {
  display: flex;
  gap: 2em;
  align-items: flex-start;
  margin: 2em 0;
}

.demo-section {
  flex: 2;
}

.code-section {
  flex: 1;
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 12px;
  padding: 20px;
}

.angle-inputs {
  display: flex;
  flex-direction: column;
  gap: 15px;
  margin: 20px 0;
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.06);
  border-radius: 12px;
  padding: 20px;
}

.angle-inputs label {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 16px;
  color: var(--ink);
}

.angle-inputs input[type="range"] {
  flex: 1;
  margin: 0 15px;
  appearance: none;
  height: 6px;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.1);
  outline: none;
}

.angle-inputs input[type="range"]::-webkit-slider-thumb {
  appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--accent);
  cursor: pointer;
}

.angle-inputs input[type="range"]::-moz-range-thumb {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--accent);
  cursor: pointer;
  border: none;
}

.angle-inputs span {
  min-width: 50px;
  font-weight: 600;
  color: var(--accent);
}

.demo-visual {
  display: flex;
  justify-content: center;
  margin: 20px 0;
  background: rgba(255, 255, 255, 0.01);
  border: 1px solid rgba(255, 255, 255, 0.06);
  border-radius: 12px;
  padding: 20px;
}

.demo-results {
  display: flex;
  gap: 20px;
  justify-content: center;
  margin: 20px 0;
}

.result {
  background: rgba(255, 255, 255, 0.02);
  border: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 12px;
  padding: 15px 20px;
  text-align: center;
  min-width: 140px;
}

.wrong-result {
  border-left: 4px solid var(--accent3);
}

.correct-result {
  border-left: 4px solid var(--accent2);
}

.result h4 {
  margin: 0 0 10px 0;
  font-size: 16px;
}

.result p {
  margin: 0;
  font-size: 24px;
  font-weight: 700;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
    "Liberation Mono", monospace;
}

.wrong-result p {
  color: var(--accent3);
}

.correct-result p {
  color: var(--accent2);
}

/* Print styles */
@media print {
  body {
    background: white;
    color: #111;
  }

  #slide-content {
    background: white;
    color: #111;
    border: none;
    box-shadow: none;
    page-break-after: always;
  }

  .navigation,
  .slide-counter {
    display: none !important;
  }

  h1,
  h2,
  h3,
  p,
  li {
    color: #111;
  }

  .card,
  .highlight-box,
  .success-box,
  .warning-box,
  .info-box,
  .status-item {
    background: #fff;
    border: 1px solid #e5e7eb;
    box-shadow: none;
    color: #111;
  }
}

/* Visual comparison layout for robot heading diagrams */
.visual-comparison {
  display: flex;
  justify-content: center;
  align-items: flex-start;
  gap: 2em;
  margin: 2em 0;
  flex-wrap: wrap;
}

.visual-comparison .approach {
  flex: 1;
  max-width: 500px;
  text-align: center;
}

.visual-comparison svg {
  margin: 0 auto;
  display: block;
}

.text-center {
  text-align: center;
}


        /* Code block styling */
        pre code {
            border: 1px solid rgba(255,255,255,0.1) !important;
            border-radius: 12px !important;
            padding: 20px !important;
            display: block;
        }

        /* Maintain our colored container backgrounds */
        .bad-code, .code-example {
            background: linear-gradient(180deg, rgba(255,123,123,0.08), rgba(255,123,123,0.04)) !important;
            border-left: 4px solid var(--accent3) !important;
            border-radius: 8px !important;
            padding: 1em !important;
        }

        .good-code, .code-solution {
            background: linear-gradient(180deg, rgba(155,255,176,0.08), rgba(155,255,176,0.04)) !important;
            border-left: 4px solid var(--accent2) !important;
            border-radius: 8px !important;
            padding: 1em !important;
        }

        .implementation-example {
            background: linear-gradient(180deg, rgba(156,39,176,0.08), rgba(156,39,176,0.04)) !important;
            border-left: 4px solid #9C27B0 !important;
            border-radius: 8px !important;
            padding: 1em !important;
        }

        .universal-class {
            background: linear-gradient(180deg, rgba(33,150,243,0.08), rgba(33,150,243,0.04)) !important;
            border-left: 4px solid #2196F3 !important;
            border-radius: 8px !important;
            padding: 1em !important;
        }

        .approach-bad, .approach-good {
            background: rgba(255,255,255,0.04) !important;
            border: 1px solid rgba(255,255,255,0.08) !important;
            border-radius: 8px !important;
            padding: 1em !important;
        }

        /* Crisp "halo" under label text to keep it readable */
        svg text {
            paint-order: stroke;
            stroke: rgba(8,12,16,.75);
            stroke-width: 3;
        }
        /* Optional: keep strokes consistent when scaling */
        svg *[stroke] {
            vector-effect: non-scaling-stroke;
        }
    </style>

    <!-- Math rendering with MathJax -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\(', '\)']],
                displayMath: [['$$', '$$'], ['\[', '\]']]
            },
            options: {
                renderActions: {
                    addMenu: []  // Disable context menu for cleaner presentation
                }
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <div class="slideshow-container">
        <div id="slide-content"></div>
    </div>

    <!-- Navigation -->
    <div class="navigation">
        <button class="nav-button" onclick="console.log('Previous button clicked!'); previousSlide()">‚óÄ Previous</button>
        <button class="nav-button" onclick="nextSlide()">Next ‚ñ∂</button>
    </div>

    <!-- Slide Counter -->
    <div class="slide-counter">
        <span id="current-slide">1</span> / <span id="total-slides">17</span>
    </div>

    <!-- Code highlighting JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>

    <!-- Leaflet JavaScript for GIS demo -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <!-- PixiJS for interactive math demos -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.4.0/pixi.min.js"></script>
    <script>
        document.addEventListener("DOMContentLoaded", () => {
            hljs.highlightAll();

            // Sanity check for D3 and fc libraries
            console.log("‚úÖ D3 loaded?", typeof d3);
            console.log("‚úÖ fc loaded?", typeof fc);

            if (typeof d3 !== 'undefined' && typeof fc !== 'undefined') {
                console.log("‚úÖ D3 version:", d3.version);
                console.log("‚úÖ fc.layoutLabel exists?", typeof fc.layoutLabel);
            } else {
                console.error("‚ùå D3 or fc libraries failed to load!");
            }
        });

        // Helper function to expand SVG viewBox to prevent text cutoff
        function expandViewBox(svg, pad = 20) {
            console.log("üìê expandViewBox called with padding:", pad);
            const node = svg.node ? svg.node() : svg;
            const box = node.getBBox();
            const oldViewBox = node.getAttribute("viewBox");
            const newViewBox = [
                box.x - pad,
                box.y - pad,
                box.width + 2 * pad,
                box.height + 2 * pad
            ].join(" ");

            console.log("   Old viewBox:", oldViewBox);
            console.log("   New viewBox:", newViewBox);

            if (svg.attr) {
                svg.attr("viewBox", newViewBox);
            } else {
                node.setAttribute("viewBox", newViewBox);
            }
        }

        // Helper function to wait for libraries to load
        function waitForLibraries(callback, maxRetries = 20) {
            let retries = 0;
            const checkInterval = setInterval(() => {
                retries++;
                if (window.d3 && window.fc) {
                    console.log("‚úÖ D3 and fc libraries loaded");
                    clearInterval(checkInterval);
                    callback();
                } else if (retries >= maxRetries) {
                    console.warn("‚ö†Ô∏è Timeout waiting for D3/fc libraries after", retries, "attempts");
                    clearInterval(checkInterval);
                } else {
                    console.log("‚è≥ Waiting for D3/fc libraries... attempt", retries);
                }
            }, 100);
        }

        // Helper function to fix SVG text layout and prevent overlap
        function fixSVGLayout(svgElement) {
            console.log("üîß fixSVGLayout called for SVG element");

            if (!window.d3 || !window.fc) {
                console.warn("‚ö†Ô∏è D3 or fc libraries not loaded yet, will retry...");
                waitForLibraries(() => {
                    console.log("üîÑ Retrying fixSVGLayout after libraries loaded");
                    fixSVGLayout(svgElement);
                });
                return;
            }

            const svg = d3.select(svgElement);
            console.log("   SVG selected with D3");

            // Expand viewBox to prevent edge clipping
            expandViewBox(svg, 25);

            // Optional: Apply label layout if there are many text elements
            const textElements = svg.selectAll("text");
            console.log('   Found ' + textElements.size() + ' text elements');

            if (textElements.size() > 4) {
                console.log("   Applying d3fc label layout for", textElements.size(), "text elements");
                // For complex layouts with many labels, use d3fc-label-layout
                try {
                    const labels = textElements.nodes();
                    const layout = fc.layoutLabel()
                        .size(d => {
                            const box = d.getBBox();
                            return [box.width, box.height];
                        })
                        .position(d => {
                            const x = parseFloat(d.getAttribute("x") || 0);
                            const y = parseFloat(d.getAttribute("y") || 0);
                            return [x, y];
                        });

                    svg.datum(labels).call(layout);
                    console.log("   ‚úÖ Label layout applied successfully");
                } catch (e) {
                    console.warn("   ‚ùå Label layout failed:", e);
                }
            } else {
                console.log("   Skipping label layout (not enough text elements)");
            }
        }

        // Helper function to compute safe SVG bounds
        function computeSvgBounds(svgNode) {
            const svg = d3.select(svgNode);
            const vbAttr = svg.attr("viewBox");
            if (vbAttr) {
                const nums = vbAttr.trim().split(/\s+/).map(Number);
                if (nums.length === 4 && nums.every(Number.isFinite)) {
                    const [vx, vy, vw, vh] = nums;
                    if (vw > 0 && vh > 0) return { x: vx, y: vy, width: vw, height: vh };
                }
            }
            // fallback: bbox + padding, and set a sane viewBox
            const b = svgNode.getBBox();
            const bounds = { x: b.x - 16, y: b.y - 16, width: b.width + 32, height: b.height + 32 };
            svg.attr("viewBox", bounds.x + " " + bounds.y + " " + bounds.width + " " + bounds.height);
            return bounds;
        }

        // Move existing <text> elements with d3fc (no new labels are created)
        window.applyLabelLayout = function applyLabelLayout(svgNode, { anneal = false } = {}) {
            if (!window.d3 || !window.fc) {
                console.warn("applyLabelLayout: d3/fc not present");
                return;
            }

            console.log('üè∑Ô∏è Applying label layout (reuse existing labels)');
            const svg = d3.select(svgNode);
            const textsSel = svg.selectAll("text");
            const textNodes = textsSel.nodes();

            if (textNodes.length < 2) {
                console.log('   Skipping layout (less than 2 text elements)');
                return; // nothing to resolve
            }

            // normalize anchors to reduce surprises
            textsSel
                .attr("dominant-baseline", function () { return this.getAttribute("dominant-baseline") || "middle"; })
                .attr("text-anchor", function () { return this.getAttribute("text-anchor") || "middle"; });

            const bounds = computeSvgBounds(svgNode);
            console.log('   Using bounds:', bounds);

            // pick strategy
            const base = anneal ? fc.layoutAnnealing() : fc.layoutGreedy();
            const strategy = fc.layoutRemoveOverlaps(base.bounds(bounds));

            // NO component: we don't want new nodes rendered
            const noop = () => {};

            // layout that measures & reads current positions off each datum (the SVGTextElement)
            const layout = fc.layoutLabel(strategy)
                .size(function (d) {
                    const bb = d.getBBox();
                    return [bb.width + 8, bb.height + 6];  // padding around label boxes
                })
                .position(function (d) {
                    return [ +d.getAttribute("x") || 0, +d.getAttribute("y") || 0 ];
                })
                .component(noop);

            // bind nodes as data and run layout
            svg.datum(textNodes).call(layout);

            // now bind those datums to the text selection
            textsSel.data(textNodes);

            // write solved positions back; keep old value as fallback
            textsSel
                .attr("x", function (d) { return (d && Number.isFinite(d.x)) ? d.x : +this.getAttribute("x"); })
                .attr("y", function (d) { return (d && Number.isFinite(d.y)) ? d.y : +this.getAttribute("y"); });
            console.log('   ‚úÖ Label layout applied to', textNodes.length, 'existing text elements (no new nodes created)');
        };

        // Move every <text> to the end of its parent so it paints on top
        function bringTextToFront(svgEl) {
            console.log('üì§ Bringing text elements to front');
            const texts = svgEl.querySelectorAll('text');
            texts.forEach(t => t.parentNode.appendChild(t)); // append = top of paint order
            console.log('   ‚úÖ Moved', texts.length, 'text elements to front');
        }

        // Ensure SVG has the filter definitions for labels
        function ensureLabelFilters(svgEl) {
            const NS = "http://www.w3.org/2000/svg";
            let defs = svgEl.querySelector("defs");
            if (!defs) {
                defs = document.createElementNS(NS, "defs");
                svgEl.insertBefore(defs, svgEl.firstChild);
            }

            if (!svgEl.querySelector("#label-shadow")) {
                const f = document.createElementNS(NS, "filter");
                f.setAttribute("id", "label-shadow");
                f.innerHTML = '<feDropShadow dx="0" dy=".7" stdDeviation="1.2" flood-color="#000" flood-opacity=".55"/>';
                defs.appendChild(f);
            }
            if (!svgEl.querySelector("#label-glow")) {
                const f = document.createElementNS(NS, "filter");
                f.setAttribute("id", "label-glow");
                f.setAttribute("x", "-20%");
                f.setAttribute("y", "-20%");
                f.setAttribute("width", "140%");
                f.setAttribute("height", "140%");
                f.innerHTML = '<feGaussianBlur in="SourceAlpha" stdDeviation="1.4" result="blur"/><feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>';
                defs.appendChild(f);
            }
        }

        // Apply styling filters to labels
        function styleLabels(svgEl, { use = "shadow" } = {}) {
            console.log('üé® Applying', use, 'filter to text labels');
            ensureLabelFilters(svgEl);
            const texts = svgEl.querySelectorAll("text");
            texts.forEach(t => {
                t.setAttribute("filter", 'url(#label-' + use + ')');
            });
            console.log('   ‚úÖ Applied', use, 'filter to', texts.length, 'text elements');
        }

        // Reduce the size of filled endpoint circles; leave stroked rings alone
        function shrinkEndpoints(svgEl, targetR = 5) {
            console.log('üî¥ Shrinking endpoint bulbs to radius', targetR);
            let shrunkCount = 0;
            svgEl.querySelectorAll('circle').forEach(c => {
                const r0 = +c.getAttribute('r') || 0;
                const fill = (c.getAttribute('fill') || '').trim().toLowerCase();
                const hasFill = fill && fill !== 'none';
                // Heuristic: rings in your slides have fill="none", endpoints are filled
                if (hasFill && r0 > targetR) {
                    c.setAttribute('r', targetR);
                    shrunkCount++;
                }
            });
            console.log('   ‚úÖ Shrunk', shrunkCount, 'filled circles from larger sizes to', targetR);
        }

        // Called after each slide's SVG is inserted (comprehensive enhancement pipeline)
        window.fixSVGLayoutAndLabels = function fixSVGLayoutAndLabels(svgEl) {
            console.log('üîß fixSVGLayoutAndLabels called - running full enhancement pipeline');

            if (window.fixSVGLayout) {
                window.fixSVGLayout(svgEl);         // your viewBox pad step
            }
            if (window.applyLabelLayout) {
                window.applyLabelLayout(svgEl);     // space labels (greedy)
            }
            bringTextToFront(svgEl);                // labels above graphics
            styleLabels(svgEl, { use: "shadow" });  // halo + subtle shadow
            shrinkEndpoints(svgEl, 5);              // smaller bulbs globally

            console.log('   ‚úÖ Enhancement pipeline completed');
        };

        // Auto-fix all SVGs when a slide is loaded
        window.addEventListener("slideLoaded", () => {
            console.log("üìÑ slideLoaded event received");
            const svgs = document.querySelectorAll("#slide-content svg");
            console.log('   Found ' + svgs.length + ' SVG(s) in slide content');

            if (svgs.length > 0) {
                // Wait for libraries to be ready before processing SVGs
                if (!window.d3 || !window.fc) {
                    console.log("‚è≥ Libraries not ready, waiting...");
                    waitForLibraries(() => {
                        svgs.forEach((svg, index) => {
                            console.log('   Processing SVG ' + (index + 1) + '/' + svgs.length);
                            fixSVGLayoutAndLabels(svg);
                        });
                    });
                } else {
                    svgs.forEach((svg, index) => {
                        console.log('   Processing SVG ' + (index + 1) + '/' + svgs.length);
                        fixSVGLayoutAndLabels(svg);
                    });
                }
            }
        });
    </script>

    <script>
// No embedded data needed for this presentation
console.log('Presentation loaded - no external data dependencies');


const slidesData = [{"content":"<div class='slide title-slide'> <style> /* --- Title hero layout (scoped to this slide) --- */ .title-slide { padding: 6vh 6vw 5vh; } .hero { display: grid; grid-template-columns: minmax(420px, 1.2fr) minmax(420px, .8fr); align-items: center; gap: clamp(24px, 5vw, 56px); margin-top: 2vh; } .hero-left { display: grid; gap: clamp(8px, 1vw, 14px); } .main-title { font-size: clamp(44px, 6.2vw, 88px); line-height: 1.05; margin: 0; margin-top: 0; background: linear-gradient(180deg,#b8f5ff 0%, #29f5c8 60%, #1bd49a 100%); -webkit-background-clip: text; background-clip: text; color: transparent; text-shadow: 0 10px 40px rgba(0,0,0,.25); } .kicker { margin: 0; font-size: clamp(18px, 2.2vw, 26px); font-weight: 600; display: inline-flex; align-items: center; gap: .6em; } .kicker::before { content: ''; width: .4em; height: 1.1em; border-radius: 2px; background: var(--accent2, #00e6a8); box-shadow: 0 0 10px rgba(0,230,168,.4); } .hero-right svg { width: 100%; height: auto; display: block; } .meta { margin-top: clamp(24px, 4vh, 48px); text-align: center; display: grid; gap: 8px; } /* tagline stays subtle */ .meta .tagline { opacity: .9; } /* footer logo */ .meta-logo { width: clamp(140px, 16vw, 240px); height: auto; margin: 10px auto 4px; display: block; filter: drop-shadow(0 8px 18px rgba(0, 255, 194, .15)) drop-shadow(0 2px 6px rgba(0, 0, 0, .35)); border-radius: 10px; } /* make 'Tech Talk' larger and bolder */ .meta .talk { font-size: clamp(36px, 5vw, 64px); font-weight: 700; letter-spacing: .5px; opacity: .95; } </style> <div class='hero'> <div class='hero-left'> <h1 class='main-title'>Stop Fighting Wraparound</h1> <p class='kicker'>Embed Your Rings!</p> </div> <div class='hero-right'> <!-- Bigger, cleaner SVG hero --> <svg viewBox='0 0 460 300'> <!-- circles --> <circle cx='120' cy='150' r='95' fill='none' stroke='#4CAF50' stroke-width='3'/> <circle cx='120' cy='150' r='65' fill='none' stroke='#4CAF50' stroke-opacity='.6' stroke-width='3'/> <!-- wrong linear distance --> <path d='M 185 150 L 55 150' stroke='#FF5722' stroke-width='2' stroke-dasharray='6,6' opacity='0.65'/> <text x='120' y='137' text-anchor='middle' fill='#FFB74D' font-weight='700' font-size='16'>140¬∞ apart?</text> <!-- correct arc distance --> <path d='M 185 150 A 95 95 0 0 0 55 150' fill='none' stroke='#4CAF50' stroke-width='3'/> <text x='120' y='182' text-anchor='middle' fill='#9CFFB0' font-weight='700' font-size='16'>20¬∞ apart!</text> <!-- endpoints (smaller bulbs) --> <circle cx='185' cy='150' r='5' fill='#FF5722'/> <circle cx='55' cy='150' r='5' fill='#2196F3'/> <!-- embed arrow/right panel --> <path d='M 230 150 L 310 150' stroke='#9aa4ad' stroke-width='2' marker-end='url(#arrowhead)'/> <text x='270' y='136' text-anchor='middle' fill='#c9d1d9' font-size='13'>embed</text> <g transform='translate(360,150)'> <line x1='-45' y1='0' x2='45' y2='0' stroke='#9aa4ad' stroke-width='1'/> <line x1='0' y1='-45' x2='0' y2='45' stroke='#9aa4ad' stroke-width='1'/> <circle cx='32' cy='0' r='5' fill='#FF5722'/> <circle cx='-32' cy='0' r='5' fill='#2196F3'/> <text x='0' y='-55' text-anchor='middle' fill='#c9d1d9' font-size='12'>‚Ñù¬≤</text> </g> <defs> <marker id='arrowhead' markerWidth='10' markerHeight='7' refX='10' refY='3.5' orient='auto'> <polygon points='0 0, 10 3.5, 0 7' fill='#9aa4ad'/> </marker> </defs> </svg> </div> </div> <div class='meta'> <p class='tagline'>A practical guide to handling ring-like quantities in code</p> <!-- footer logo instead of the 'Ceres' text --> <img src='../ceres-tech-logo.png' alt='Ceres AI' class='meta-logo' /> <p class='talk'>Tech Talk</p> </div> </div> ","title":"Stop Fighting Wraparound"},{"content":"<div class='slide'> <h1>The Bug We've All Written</h1> <div class='highlight-box'> <h3>‚ùå The Naive Approach</h3> <pre><code class=\"language-python\">def average_angle(angle1, angle2):\n    return (angle1 + angle2) / 2  # Seems reasonable...\n\n# Example: Average heading between two compass readings\nheading1 = 350  # degrees\nheading2 = 10   # degrees\n\naverage = average_angle(heading1, heading2)\nprint(f\"Average: {average}¬∞\")  # 180¬∞ - COMPLETELY WRONG!</code></pre> </div> <div class='visual-demo'> <svg width='600' height='600' viewBox='0 0 300 300'> <!-- Compass circle --> <circle cx='150' cy='150' r='120' fill='none' stroke='#333' stroke-width='2'/> <!-- Compass labels with stroke for better readability --> <text x='150' y='20' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107' paint-order='stroke' stroke='#0b0f14' stroke-width='3'>N (0¬∞)</text> <text x='280' y='155' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107' paint-order='stroke' stroke='#0b0f14' stroke-width='3'>E (90¬∞)</text> <text x='150' y='290' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107' paint-order='stroke' stroke='#0b0f14' stroke-width='3'>S (180¬∞)</text> <text x='20' y='155' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107' paint-order='stroke' stroke='#0b0f14' stroke-width='3'>W (270¬∞)</text> <!-- Heading 1: 350¬∞ --> <line x1='150' y1='150' x2='140' y2='30' stroke='#2196F3' stroke-width='4'/> <circle cx='140' cy='30' r='8' fill='#2196F3'/> <text x='110' y='20' font-size='14' fill='#FFC107'>350¬∞</text> <!-- Heading 2: 10¬∞ --> <line x1='150' y1='150' x2='160' y2='30' stroke='#4CAF50' stroke-width='4'/> <circle cx='160' cy='30' r='8' fill='#4CAF50'/> <text x='190' y='20' font-size='14' fill='#FFC107'>10¬∞</text> <!-- Wrong average: 180¬∞ --> <line x1='150' y1='150' x2='150' y2='270' stroke='#FF5722' stroke-width='4' stroke-dasharray='5,5'/> <circle cx='150' cy='270' r='8' fill='#FF5722'/> <text x='150' y='260' text-anchor='middle' font-size='16' fill='#FF5722' font-weight='bold'> Wrong: 180¬∞ </text> <!-- Correct average indicator --> <line x1='150' y1='150' x2='150' y2='30' stroke='#FFC107' stroke-width='3' opacity='0.7'/> <text x='220' y='60' font-size='14' fill='#ffffff' font-weight='bold'>Should be ~0¬∞!</text> </svg> </div> <div class='warning-box'> <h3>What Went Wrong?</h3> <ul> <li>350¬∞ and 10¬∞ are <strong>20¬∞ apart</strong> on the circle</li> <li>But linear math sees them as <strong>340¬∞ apart</strong></li> <li>The average points in the <strong>opposite direction</strong>!</li> </ul> </div> </div> <script> // Fix SVG layout and labels when this slide is displayed console.log('üéØ Slide 02-the-bug script executing'); setTimeout(() => { console.log('üéØ Slide 02-the-bug timeout triggered'); const svg = document.querySelector('.visual-demo svg'); if (svg) { console.log(' Found SVG in .visual-demo'); if (window.fixSVGLayoutAndLabels) { console.log(' Calling fixSVGLayoutAndLabels from slide script'); window.fixSVGLayoutAndLabels(svg); } else { console.warn(' fixSVGLayoutAndLabels function not found on window'); } } else { console.warn(' No SVG found in .visual-demo'); } }, 100); <\\/script> ","title":"The Bug We've All Written"},{"content":"<div class='slide'> <h1>The Midnight Bug</h1> <div class='info-box'> <h3>üìÖ Real Scenario: Event Duration Tracking</h3> <p>Meeting started at <strong>23:45</strong> (11:45 PM)</p> <p>Meeting ended at <strong>00:15</strong> (12:15 AM)</p> </div> <div class='code-comparison'> <div class='highlight-box'> <h4>‚ùå What Everyone Tries First</h4> <pre><code>start_time = 23.75  # 23:45 in decimal hours\nend_time = 0.25     # 00:15 in decimal hours\n\nduration = end_time - start_time\nprint(f\"Duration: {duration} hours\")\n# Output: -23.5 hours ü§¶</code></pre> </div> <div class='warning-box'> <h4>ü§î The Hacky 'Fix'</h4> <pre><code>if end_time < start_time:\n    # Must have crossed midnight\n    duration = (24 - start_time) + end_time\nelse:\n    duration = end_time - start_time\n    \n# More special cases...\nif crossed_dst:  # Daylight savings\n    duration += 1  # or -1? üò≠</code></pre> </div> </div> <div class='clock-visual'> <svg width='1200' height='500' viewBox='0 0 800 300'> <!-- Linear representation --> <g transform='translate(30, 80)'> <text x='150' y='-20' text-anchor='middle' font-size='14' font-weight='bold' fill='#FFC107'>Linear View:</text> <line x1='0' y1='20' x2='300' y2='20' stroke='#333' stroke-width='2'/> <!-- Time markers --> <line x1='0' y1='15' x2='0' y2='25' stroke='#333' stroke-width='2'/> <text x='0' y='40' text-anchor='middle' font-size='12' fill='#FFC107'>0:00</text> <line x1='150' y1='15' x2='150' y2='25' stroke='#333' stroke-width='2'/> <text x='150' y='40' text-anchor='middle' font-size='12' fill='#FFC107'>12:00</text> <line x1='300' y1='15' x2='300' y2='25' stroke='#333' stroke-width='2'/> <text x='300' y='40' text-anchor='middle' font-size='12' fill='#FFC107'>24:00</text> <!-- Start time: 23:45 (23.75/24 * 300 = 296.25) --> <circle cx='296' cy='20' r='8' fill='#2196F3'/> <text x='296' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>23:45</text> <!-- End time: 00:15 (0.25/24 * 300 = 3.125) --> <circle cx='3' cy='20' r='8' fill='#4CAF50'/> <text x='3' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>00:15</text> <!-- Wrong distance --> <path d='M 296 20 L 3 20' stroke='#FF5722' stroke-width='2' stroke-dasharray='5,5' opacity='0.5'/> <text x='150' y='80' text-anchor='middle' fill='#FF5722' font-size='14'>Linear: -23.5 hours!</text> </g> <!-- Circular representation --> <g transform='translate(550, 150)'> <text x='0' y='-90' text-anchor='middle' font-size='14' font-weight='bold' fill='#FFC107'>Circular View:</text> <circle cx='0' cy='0' r='70' fill='none' stroke='#333' stroke-width='2'/> <!-- Clock numbers --> <text x='0' y='-55' text-anchor='middle' font-size='12' fill='#FFC107'>12</text> <text x='55' y='5' text-anchor='middle' font-size='12' fill='#FFC107'>3</text> <text x='0' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>6</text> <text x='-55' y='5' text-anchor='middle' font-size='12' fill='#FFC107'>9</text> <!-- Start: 23:45 --> <line x1='0' y1='0' x2='-10' y2='-68' stroke='#2196F3' stroke-width='3'/> <circle cx='-10' cy='-68' r='8' fill='#2196F3'/> <!-- End: 00:15 --> <line x1='0' y1='0' x2='10' y2='-68' stroke='#4CAF50' stroke-width='3'/> <circle cx='10' cy='-68' r='8' fill='#4CAF50'/> <!-- Correct arc --> <path d='M -10 -68 A 70 70 0 0 1 10 -68' fill='none' stroke='#4CAF50' stroke-width='3'/> <text x='0' y='90' text-anchor='middle' fill='#4CAF50' font-size='14' font-weight='bold'> Correct: 30 minutes! </text> </g> </svg> </div> <div class='success-box'> <h3>üí° The Key Insight</h3> <p>Time-of-day is a <strong>24-hour ring</strong>, not a line!</p> <p>Linear arithmetic breaks at the wraparound point.</p> </div> </div> ","title":"The Midnight Bug"},{"content":"<div class='slide'> <h1>Interactive Demo</h1> <div class='demo-container'> <div class='demo-section'> <h3>üéÆ Try It Yourself: Angle Averaging</h3> <div class='angle-inputs'> <label> Angle 1: <input type='range' id='angle1' min='0' max='359' value='350'> <span id='angle1-display'>350¬∞</span> </label> <label> Angle 2: <input type='range' id='angle2' min='0' max='359' value='10'> <span id='angle2-display'>10¬∞</span> </label> </div> <div class='demo-visual'> <svg width='400' height='400' viewBox='0 0 400 400' id='demo-svg'> <!-- Circle --> <circle cx='200' cy='200' r='150' fill='none' stroke='#333' stroke-width='2'/> <!-- Compass labels --> <text x='200' y='30' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107'>0¬∞</text> <text x='370' y='205' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107'>90¬∞</text> <text x='200' y='380' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107'>180¬∞</text> <text x='30' y='205' text-anchor='middle' font-size='16' font-weight='bold' fill='#FFC107'>270¬∞</text> <!-- Angle 1 line --> <line id='angle1-line' x1='200' y1='200' x2='200' y2='50' stroke='#2196F3' stroke-width='4'/> <circle id='angle1-point' cx='200' cy='50' r='8' fill='#2196F3'/> <!-- Angle 2 line --> <line id='angle2-line' x1='200' y1='200' x2='200' y2='50' stroke='#4CAF50' stroke-width='4'/> <circle id='angle2-point' cx='200' cy='50' r='8' fill='#4CAF50'/> <!-- Average (wrong) --> <line id='avg-wrong-line' x1='200' y1='200' x2='200' y2='350' stroke='#FF5722' stroke-width='3' stroke-dasharray='5,5' opacity='0'/> <circle id='avg-wrong-point' cx='200' cy='350' r='6' fill='#FF5722' opacity='0'/> <!-- Average (correct) --> <line id='avg-correct-line' x1='200' y1='200' x2='200' y2='50' stroke='#FFC107' stroke-width='4'/> <circle id='avg-correct-point' cx='200' cy='50' r='8' fill='#FFC107'/> </svg> </div> <div class='demo-results'> <div class='result wrong-result'> <h4>‚ùå Linear Average</h4> <p id='wrong-result'>180¬∞</p> </div> <div class='result correct-result'> <h4>‚úÖ Circular Average</h4> <p id='correct-result'>0¬∞</p> </div> </div> </div> <div class='code-section'> <h3>The Code Behind It</h3> <pre><code id=\"demo-code\">function circularAverage(a1, a2) {\n    // Convert to radians\n    const theta1 = a1 * Math.PI / 180;\n    const theta2 = a2 * Math.PI / 180;\n    \n    // Embed on unit circle\n    const v1 = [Math.cos(theta1), Math.sin(theta1)];\n    const v2 = [Math.cos(theta2), Math.sin(theta2)];\n    \n    // Average vectors\n    const avgVec = [(v1[0] + v2[0])/2, (v1[1] + v2[1])/2];\n    \n    // Convert back to angle\n    const avgTheta = Math.atan2(avgVec[1], avgVec[0]);\n    return (avgTheta * 180 / Math.PI + 360) % 360;\n}</code></pre> </div> </div> </div> ","title":"Interactive Demo"},{"content":"<div class='slide'> <h1>Real Example: Robot/Drone Heading Control</h1> <div class='problem-setup'> <h3>ü§ñ The Scenario</h3> <p>PID controller needs to turn robot from 350¬∞ to 10¬∞</p> </div> <div class='visual-comparison'> <div class='approach bad-approach'> <h4>‚ùå Naive PID Error</h4> <svg width='500' height='500' viewBox='0 0 250 250'> <circle cx='125' cy='125' r='100' fill='none' stroke='#333' stroke-width='2'/> <!-- Current heading: 350¬∞ --> <line x1='125' y1='125' x2='115' y2='25' stroke='#2196F3' stroke-width='4'/> <circle cx='115' cy='25' r='6' fill='#2196F3'/> <text x='75' y='15' font-size='12' fill='#FFC107'>Current: 350¬∞</text> <!-- Target heading: 10¬∞ --> <line x1='125' y1='125' x2='135' y2='25' stroke='#4CAF50' stroke-width='4'/> <circle cx='135' cy='25' r='6' fill='#4CAF50'/> <text x='175' y='15' font-size='12' fill='#FFC107'>Target: 10¬∞</text> <!-- Wrong rotation path --> <path d='M 115 25 A 100 100 0 1 1 135 25' fill='none' stroke='#FF5722' stroke-width='3' stroke-dasharray='5,5'/> <text x='125' y='200' text-anchor='middle' font-size='14' fill='#FF5722' font-weight='bold'> Error: -340¬∞ </text> <text x='125' y='220' text-anchor='middle' font-size='12' fill='#FF5722'> Spins backward! </text> </svg> <pre><code>error = target - current\nerror = 10 - 350 = -340¬∞\n# Robot spins almost full circle\n# the wrong way!</code></pre> </div> <div class='approach good-approach'> <h4>‚úÖ Embedded Solution</h4> <svg width='500' height='500' viewBox='0 0 250 250'> <circle cx='125' cy='125' r='100' fill='none' stroke='#333' stroke-width='2'/> <!-- Current heading: 350¬∞ --> <line x1='125' y1='125' x2='115' y2='25' stroke='#2196F3' stroke-width='4'/> <circle cx='115' cy='25' r='6' fill='#2196F3'/> <text x='75' y='15' font-size='12' fill='#FFC107'>Current: 350¬∞</text> <!-- Target heading: 10¬∞ --> <line x1='125' y1='125' x2='135' y2='25' stroke='#4CAF50' stroke-width='4'/> <circle cx='135' cy='25' r='6' fill='#4CAF50'/> <text x='175' y='15' font-size='12' fill='#FFC107'>Target: 10¬∞</text> <!-- Correct rotation path --> <path d='M 115 25 A 100 100 0 0 1 135 25' fill='none' stroke='#4CAF50' stroke-width='3'/> <text x='125' y='200' text-anchor='middle' font-size='14' fill='#4CAF50' font-weight='bold'> Error: +20¬∞ </text> <text x='125' y='220' text-anchor='middle' font-size='12' fill='#4CAF50'> Efficient turn! </text> </svg> <pre><code>def heading_error(current, target):\n    c_vec = [cos(current), sin(current)]\n    t_vec = [cos(target), sin(target)]\n    return atan2(cross(c_vec, t_vec), \n                 dot(c_vec, t_vec))\n# Returns: +20¬∞ (shortest path!)</code></pre> </div> </div> <div class='implementation'> <h3>Complete PID Controller Fix</h3> <pre><code class=\"language-python\">class HeadingController:\n    def __init__(self, kp=1.0, ki=0.1, kd=0.05):\n        self.kp, self.ki, self.kd = kp, ki, kd\n        self.integral = 0\n        self.last_error = 0\n        \n    def compute_control(self, current_heading, target_heading, dt):\n        # Embed both headings as vectors\n        current_vec = np.array([np.cos(current_heading), np.sin(current_heading)])\n        target_vec = np.array([np.cos(target_heading), np.sin(target_heading)])\n        \n        # Compute signed angle error (always shortest path)\n        error = np.arctan2(\n            current_vec[0] * target_vec[1] - current_vec[1] * target_vec[0],\n            current_vec[0] * target_vec[0] + current_vec[1] * target_vec[1]\n        )\n        \n        # Standard PID computation (now with correct error!)\n        self.integral += error * dt\n        derivative = (error - self.last_error) / dt\n        \n        control = self.kp * error + self.ki * self.integral + self.kd * derivative\n        self.last_error = error\n        \n        return control  # Angular velocity command</code></pre> </div> <div class='impact-note'> <p>üí∞ <strong>Real Impact:</strong> Shipping routes crossing the Pacific get drawn spanning ~359¬∞ longitude instead of the short ~20 nautical mile path due to antimeridian wraparound bugs in mapping SDKs</p> </div> </div> ","title":"Real Example: Robot/Drone Heading Control"},{"content":"<div class='slide color-interpolation'> <style> /* Scoped styles for color interpolation slide */ .color-interpolation { padding: 2vh 3vw; display: flex; flex-direction: column; gap: 1.5vh; } .color-interpolation h1 { font-size: clamp(24px, 3vw, 40px); margin: 0 0 1vh 0; text-align: center; background: linear-gradient(135deg, #ff6b6b, #4ecdc4); -webkit-background-clip: text; background-clip: text; color: transparent; } .color-interpolation .card { background: rgba(255, 255, 255, 0.04); border: 1px solid rgba(255, 255, 255, 0.09); border-radius: 14px; padding: 14px 16px; margin-bottom: 1vh; } .color-interpolation .drag-wrap { display: grid; grid-template-columns: 420px 1fr; gap: 28px; align-items: start; flex: 1; } @media (max-width: 960px) { .color-interpolation .drag-wrap { grid-template-columns: 1fr; } } .color-interpolation .drag-wheel { position: relative; width: 400px; height: 400px; margin: 0 auto; } .color-interpolation .drag-wheel .wheel { position: absolute; inset: 0; border-radius: 50%; /* Red at North: default starting position is top */ background: conic-gradient( hsl(0, 100%, 50%), hsl(60, 100%, 50%), hsl(120, 100%, 50%), hsl(180, 100%, 50%), hsl(240, 100%, 50%), hsl(300, 100%, 50%), hsl(360, 100%, 50%) ); box-shadow: 0 10px 26px rgba(0, 0, 0, 0.35); } /* Concentric inner mask to make a neat ring (no offset) */ .color-interpolation .drag-wheel .mask { position: absolute; inset: 42px; background: #0b1117; border-radius: 50%; box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.08); pointer-events: none; } .color-interpolation .drag-wheel svg { position: absolute; inset: 0; overflow: visible; } .color-interpolation .legend2 { display: grid; gap: 8px; color: #cfe0f1; font-size: 14px; } .color-interpolation .chip-row { display: flex; gap: 14px; align-items: center; flex-wrap: wrap; } .color-interpolation .chip { display: inline-flex; align-items: center; gap: 8px; padding: 6px 10px; border: 1px solid rgba(255, 255, 255, 0.12); border-radius: 10px; background: rgba(255, 255, 255, 0.02); } .color-interpolation .dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.35) inset; } .color-interpolation .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace; } .color-interpolation .midbars { display: grid; gap: 8px; margin-top: 10px; } .color-interpolation .midbars .bar { height: 18px; border: 1px solid rgba(255, 255, 255, 0.12); border-radius: 10px; } </style> <h1>Drag the Hues on the Wheel</h1> <div class='card'> <p> Drag the two handles <strong>A</strong> and <strong>B</strong> on the hue wheel. The vectors are colored by their hues. We show two 'midpoints': the <strong>correct circular midpoint</strong> (shortest arc, <code>t=0.5</code>) and the <strong>naive linear midpoint</strong> (just averaging numbers). Watch how naive linear often cuts through unrelated hues. </p> </div> <div class='drag-wrap'> <div class='drag-wheel' aria-label='Hue wheel with draggable handles'> <div class='wheel'></div> <div class='mask'></div> <svg id='dwSVG' viewBox='0 0 400 400' width='400' height='400'> <defs> <filter id='vec-shadow'> <feDropShadow dx='0' dy='1' stdDeviation='1.2' flood-color='#000' flood-opacity='.65' /> </filter> </defs> <!-- guide ring --> <circle cx='200' cy='200' r='179' fill='none' stroke='rgba(255,255,255,.22)' stroke-width='1' /> <!-- arc between A and B (shortest arc) --> <path id='dwArc' d='' fill='none' stroke='#FFD180' stroke-width='5' stroke-linecap='round' stroke-dasharray='6,7' opacity='.9' /> <!-- vectors --> <g id='vecA' filter='url(#vec-shadow)'> <line id='lineA' x1='200' y1='200' x2='200' y2='42' stroke='#fff' stroke-width='7' /> <circle id='handleA' cx='200' cy='42' r='9' fill='#fff' stroke='rgba(0,0,0,.5)' stroke-width='2' /> <text id='labelA' x='200' y='28' text-anchor='middle' fill='#e6eef9' font-size='13' > A </text> </g> <g id='vecB' filter='url(#vec-shadow)'> <line id='lineB' x1='200' y1='200' x2='200' y2='42' stroke='#fff' stroke-width='7' /> <circle id='handleB' cx='200' cy='42' r='9' fill='#fff' stroke='rgba(0,0,0,.5)' stroke-width='2' /> <text id='labelB' x='200' y='28' text-anchor='middle' fill='#e6eef9' font-size='13' > B </text> </g> <!-- correct midpoint vector --> <g id='vecMid' filter='url(#vec-shadow)'> <line id='lineMid' x1='200' y1='200' x2='200' y2='42' stroke='#fff' stroke-width='7' /> <circle id='handleMid' cx='200' cy='42' r='9' fill='#fff' stroke='rgba(0,0,0,.5)' stroke-width='2' /> <text id='labelMid' x='200' y='28' text-anchor='middle' fill='#e6eef9' font-size='13' > circular mid </text> </g> <!-- naive midpoint vector --> <g id='vecNaive' filter='url(#vec-shadow)'> <line id='lineNaive' x1='200' y1='200' x2='200' y2='42' stroke='#fff' stroke-width='5' stroke-dasharray='4,6' /> <circle id='handleNaive' cx='200' cy='42' r='7' fill='#fff' stroke='rgba(0,0,0,.5)' stroke-width='2' /> <text id='labelNaive' x='200' y='28' text-anchor='middle' fill='#e6eef9' font-size='12' > naive mid </text> </g> </svg> </div> <div class='legend2'> <div class='chip-row'> <div class='chip'> <span class='dot' id='dotA'></span> <span class='mono'>A: <span id='degA'>0¬∞</span></span> </div> <div class='chip'> <span class='dot' id='dotB'></span> <span class='mono'>B: <span id='degB'>0¬∞</span></span> </div> <div class='chip'> <span class='dot' id='dotMid'></span> <span class='mono' >Circular mid (t=0.5): <span id='degMid'>0¬∞</span></span > </div> <div class='chip'> <span class='dot' id='dotNaive'></span> <span class='mono'>Naive mid: <span id='degNaive'>0¬∞</span></span> </div> </div> <div class='midbars'> <div class='bar' id='barCircular' title='Circular midpoint path'></div> <small> Correct (circular): follows the shorter arc between A and B. </small> <div class='bar' id='barNaive' title='Naive midpoint colors'></div> <small> Naive (linear hue numbers): can jump across unrelated hues. </small> </div> </div> </div> </div> ","title":"Drag the Hues on the Wheel"},{"content":"<div class='slide'> <h1>Hidden Rings Everywhere: Beyond Angles & Time</h1> <div class='warning-box'> <h3>üîç Circular Quantities Hide in Plain Sight</h3> <p>It's not just angles, time, and colors that wrap around. Here are the sneaky cyclic variables that cause bugs when you least expect them:</p> </div> <div class='pattern-table'> <table style='width: 100%; border-collapse: collapse;'> <thead> <tr style='background: rgba(33, 150, 243, 0.1); border-bottom: 2px solid #2196F3;'> <th style='padding: 12px; text-align: left; width: 30%;'>Domain</th> <th style='padding: 12px; text-align: left; width: 35%;'>‚ùå Where Naive Math Fails</th> <th style='padding: 12px; text-align: left; width: 35%;'>‚úÖ Correct Embedding</th> </tr> </thead> <tbody> <tr style='border-bottom: 1px solid #444;'> <td style='padding: 10px;'><strong>üìÖ Weekdays</strong><br><code>d ‚àà {0..6}</code></td> <td style='padding: 10px;'>Mean of Sat(6) and Mon(1) = 3.5 (Wed)?<br><span style='color: #FF5722;'>Wrong! Should be Sunday</span></td> <td style='padding: 10px;'><code>(cos(2œÄd/7), sin(2œÄd/7))</code></td> </tr> <tr style='border-bottom: 1px solid #444; background: rgba(255, 255, 255, 0.02);'> <td style='padding: 10px;'><strong>üîß Rotary Encoders</strong><br><code>n ‚àà [0, 4096)</code></td> <td style='padding: 10px;'>4095 ‚Üí 1 looks like ‚àí4094 ticks<br><span style='color: #FF5722;'>Actually just 2 ticks forward!</span></td> <td style='padding: 10px;'><code>(cos(2œÄn/N), sin(2œÄn/N))</code></td> </tr> <tr style='border-bottom: 1px solid #444;'> <td style='padding: 10px;'><strong>üåç Longitude</strong><br><code>Œª ‚àà [‚àí180¬∞, 180¬∞)</code></td> <td style='padding: 10px;'>Mean of 179¬∞E and 179¬∞W = 0¬∞?<br><span style='color: #FF5722;'>Points are 2¬∞ apart, not at Greenwich!</span></td> <td style='padding: 10px;'>3D vectors on sphere:<br><code>(cos(lat)cos(lon), cos(lat)sin(lon), sin(lat))</code></td> </tr> <tr style='border-bottom: 1px solid #444; background: rgba(255, 255, 255, 0.02);'> <td style='padding: 10px;'><strong>üì° Signal Phase</strong><br><code>œÜ ‚àà [‚àíœÄ, œÄ)</code></td> <td style='padding: 10px;'>Phase unwrapping creates artificial jumps<br><span style='color: #FF5722;'>Destroys true periodicity</span></td> <td style='padding: 10px;'>Complex: <code>e<sup>iœÜ</sup> = cos(œÜ) + i¬∑sin(œÜ)</code></td> </tr> <tr style='border-bottom: 1px solid #444;'> <td style='padding: 10px;'><strong>üíç Ring Buffers</strong><br><code>idx ‚àà [0, size)</code></td> <td style='padding: 10px;'><code>tail - head</code> wrong when wrapped<br><span style='color: #FF5722;'>Buffer looks full when nearly empty!</span></td> <td style='padding: 10px;'><code>(idx + size) % size</code><br>or embed as angle</td> </tr> <tr style='border-bottom: 1px solid #444; background: rgba(255, 255, 255, 0.02);'> <td style='padding: 10px;'><strong>‚öôÔ∏è Gear Teeth</strong><br><code>tooth ‚àà [0, N)</code></td> <td style='padding: 10px;'>Tooth 0 and Tooth N-1 look maximally apart<br><span style='color: #FF5722;'>They're actually neighbors!</span></td> <td style='padding: 10px;'><code>(cos(2œÄt/N), sin(2œÄt/N))</code></td> </tr> <tr style='border-bottom: 1px solid #444;'> <td style='padding: 10px;'><strong>üß¨ Circadian Phase</strong><br><code>t ‚àà [0, 24h)</code></td> <td style='padding: 10px;'>Sleep at 23:00 and 01:00 averages to noon?<br><span style='color: #FF5722;'>Should be midnight!</span></td> <td style='padding: 10px;'><code>(cos(2œÄt/24), sin(2œÄt/24))</code></td> </tr> <tr style='border-bottom: 1px solid #444; background: rgba(255, 255, 255, 0.02);'> <td style='padding: 10px;'><strong>üìä Months of Year</strong><br><code>m ‚àà {1..12}</code></td> <td style='padding: 10px;'>Dec(12) to Jan(1) = -11 months?<br><span style='color: #FF5722;'>Just 1 month forward!</span></td> <td style='padding: 10px;'><code>(cos(2œÄm/12), sin(2œÄm/12))</code></td> </tr> </tbody> </table> </div> <div class='highlight-box'> <h3>üí° The Universal Solution</h3> <div class='formula-showcase'> <p style='text-align: center; font-size: 18px; margin: 15px 0;'> <strong>For ANY cyclic quantity with period T starting at offset s:</strong> </p> <p style='text-align: center; font-size: 20px; background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 8px;'> <code>Œ∏ = 2œÄ(value - s)/T</code> ‚Üí <code>(cos(Œ∏), sin(Œ∏))</code> </p> <p style='text-align: center; margin-top: 15px;'> Do all your math in vector space, then project back if needed! </p> </div> </div> <div class='info-box'> <h3>üéØ When to Suspect a Hidden Ring</h3> <div class='two-column'> <div> <h4>üö© Red Flags in Your Data</h4> <ul> <li>Values that 'roll over' or 'wrap'</li> <li>Modulo operations in the code</li> <li>Special cases for 'crossing midnight'</li> <li>Discontinuous jumps in time series</li> <li>'Distance' that depends on direction</li> </ul> </div> <div> <h4>üêõ Classic Bug Patterns</h4> <ul> <li>Averages that are wildly wrong</li> <li>Interpolation that takes the 'long way'</li> <li>Derivatives with impossible spikes</li> <li>Sorting that puts neighbors far apart</li> <li>Clustering that splits natural groups</li> </ul> </div> </div> </div> </div>","title":"Hidden Rings Everywhere: Beyond Angles & Time"},{"content":"<div class='slide' style='display:grid; gap:12px;'> <h1>üåç GIS Demo: Longitude Wraparound at the International Date Line</h1> <div class='info-box'> <h3>Real-World Problem: Computing Geographic Means</h3> <p>When averaging GPS coordinates near ¬±180¬∞ longitude (International Date Line), linear arithmetic fails spectacularly. A farm field split by the date line appears to span the entire globe!</p> </div> <div id='map' style='height:600px; border-radius:12px; overflow:hidden; border:1px solid rgba(255,255,255,.15)'></div> <div style='display:flex; gap:16px; flex-wrap:wrap; align-items:center;'> <label><input type='checkbox' id='worldCopy' checked> worldCopyJump (wrap world)</label> <label><input type='checkbox' id='noWrapTiles'> tile noWrap (stop wrapping tiles)</label> <span id='readout' style='opacity:.9; font-family: monospace;'>Circular mean: ‚Ä¶</span> </div> <div class='success-box'> <h3>üéØ Try This: Drag the markers across the International Date Line!</h3> <p><strong>Red marker</strong> = Wrong linear mean | <strong>Green marker</strong> = Correct circular mean</p> <p>Watch how the linear mean jumps to the middle of the Atlantic while the circular mean stays put! This is the classic longitude wraparound bug.</p> </div> <div class='code-example'> <h3>Spherical Coordinate Embedding</h3> <pre><code class=\"language-python\"># For full lat/long geometry operations\ndef latlon_to_cartesian(lat, lon):\n    \"\"\"Embed (lat,lon) in R¬≥ for linear operations\"\"\"\n    lat_rad = np.radians(lat)\n    lon_rad = np.radians(lon)\n    return np.array([\n        np.cos(lat_rad) * np.cos(lon_rad),  # x\n        np.cos(lat_rad) * np.sin(lon_rad),  # y  \n        np.sin(lat_rad)                     # z\n    ])\n\n# Geographic centroid (works across antimeridian!)\ndef geographic_centroid(lat_lon_pairs):\n    cartesian_points = [latlon_to_cartesian(lat, lon) \n                       for lat, lon in lat_lon_pairs]\n    mean_cartesian = np.mean(cartesian_points, axis=0)\n    mean_cartesian /= np.linalg.norm(mean_cartesian)  # Back to unit sphere\n    \n    # Convert back to lat/lon\n    lat = np.degrees(np.arcsin(mean_cartesian[2]))\n    lon = np.degrees(np.arctan2(mean_cartesian[1], mean_cartesian[0]))\n    return lat, lon</code></pre> </div> <div class='warning-box'> <h3>üè¢ Company Applications</h3> <ul> <li><strong>Spatial Statistics:</strong> Computing true centroids for service areas</li> <li><strong>Route Optimization:</strong> Distance calculations that work globally</li> <li><strong>Geofencing:</strong> Boundary checks that don't break at meridians</li> <li><strong>Data Quality:</strong> Detecting GPS outliers using proper spherical distance</li> </ul> </div> </div> ","title":"üåç GIS Demo: Longitude Wraparound at the International Date Line"},{"content":"<div class='slide'> <h1>When Zero Isn't Special: Arbitrary Wrap Points</h1> <div class='warning-box'> <h3>üéØ Real Hardware Doesn't Care About Zero</h3> <p>Many circular quantities in the wild wrap at arbitrary values, not nice round numbers. The math still works‚Äîyou just need to normalize first!</p> </div> <div class='two-column-equal'> <div class='card'> <h3>üìä Common Non-Zero Wrap Domains</h3> <div class='example-list'> <div class='example-item'> <h4>üß≠ Compass: [-180¬∞, +180¬∞)</h4> <p>Wraps at ¬±180¬∞, not 0¬∞/360¬∞</p> <code>bearing ‚àà [-180, 180)</code> </div> <div class='example-item'> <h4>üîß Rotary Encoder: [1000, 5096)</h4> <p>12-bit encoder with arbitrary offset</p> <code>counts ‚àà [1000, 5096)</code> </div> <div class='example-item'> <h4>üì° Phase: [-œÄ, +œÄ)</h4> <p>Centered around zero, not starting at it</p> <code>phase ‚àà [-œÄ, œÄ)</code> </div> <div class='example-item'> <h4>üóìÔ∏è Fiscal Year: [Apr, Mar]</h4> <p>Wraps at March/April boundary</p> <code>month ‚àà [4, 3] (mod 12)</code> </div> <div class='example-item'> <h4>üå°Ô∏è ADC Values: [512, 3584)</h4> <p>Sensor with DC offset and limited range</p> <code>adc ‚àà [512, 3584)</code> </div> </div> </div> <div class='card'> <h3>‚ú® The Universal Transform</h3> <div class='formula-showcase' style='background: rgba(76, 175, 80, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;'> <h4>For any circular quantity:</h4> <p><code>value ‚àà [min, max)</code></p> <p style='margin: 15px 0;'>‚Üì</p> <p><strong>1. Normalize to [0, 1):</strong></p> <p><code>t = (value - min) / (max - min)</code></p> <p style='margin: 15px 0;'>‚Üì</p> <p><strong>2. Embed on unit circle:</strong></p> <p><code>v = (cos(2œÄt), sin(2œÄt))</code></p> <p style='margin: 15px 0;'>‚Üì</p> <p><strong>3. Do your math in ‚Ñù¬≤</strong></p> <p style='margin: 15px 0;'>‚Üì</p> <p><strong>4. Project back if needed:</strong></p> <p><code>result = min + (max-min) √ó atan2(v.y, v.x)/(2œÄ)</code></p> </div> </div> </div> <div class='success-box'> <h3>üíª Code Example: Averaging Compass Bearings</h3> <div class='code-example'> <pre><code class=\"language-python\"># PROBLEM: Compass uses [-180¬∞, +180¬∞) not [0¬∞, 360¬∞)\nbearings = [170, 175, -175, -170]  # All pointing roughly south\n\n# WRONG: Simple average\nnaive_mean = np.mean(bearings)  # = 0¬∞ (North!) ü§¶\n\n# RIGHT: Normalize ‚Üí Embed ‚Üí Average ‚Üí Denormalize\ndef circular_mean(values, min_val, max_val):\n    # Step 1: Normalize to [0, 1)\n    period = max_val - min_val\n    normalized = [(v - min_val) / period for v in values]\n    \n    # Step 2: Embed on circle\n    vectors = [(np.cos(2*np.pi*t), np.sin(2*np.pi*t)) for t in normalized]\n    \n    # Step 3: Average in vector space\n    mean_vector = np.mean(vectors, axis=0)\n    \n    # Step 4: Project back to original domain\n    angle = np.atan2(mean_vector[1], mean_vector[0])\n    result = min_val + (angle / (2*np.pi)) * period\n    if result < min_val:\n        result += period\n    return result\n\ncorrect_mean = circular_mean(bearings, -180, 180)  # ‚âà 175¬∞ South! ‚úÖ</code></pre> </div> </div> <div class='info-box'> <h3>üîß Practical Examples</h3> <div class='three-column'> <div> <h4>üéÆ Game Development</h4> <div class='code-snippet'> <pre><code># Joystick angle ‚àà [-œÄ, œÄ]\njs_angle = atan2(js.y, js.x)\n# Don't compare directly!\n# Normalize first</code></pre> </div> </div> <div> <h4>ü§ñ Robotics</h4> <div class='code-snippet'> <pre><code># Encoder wraps at 8192\n# but starts at 1000\nactual_pos = 1000 + \n  (raw - 1000) % 7192</code></pre> </div> </div> <div> <h4>üìä Time Series</h4> <div class='code-snippet'> <pre><code># Fiscal quarters Q2-Q1\n# April = month 0\nfiscal_month = \n  (cal_month - 4) % 12</code></pre> </div> </div> </div> </div> <div class='highlight-box'> <h3>üéØ Key Insight</h3> <p style='font-size: 18px; text-align: center; margin: 20px 0;'> <strong>The 'zero point' is arbitrary!</strong> What matters is the <em>topology</em>‚Äîthat values wrap around. </p> <p style='text-align: center;'> Always normalize to [0, 1) or [0, 2œÄ) before embedding. Your vector math doesn't care where the original wrap point was. </p> </div> </div>","title":"When Zero Isn't Special: Arbitrary Wrap Points"},{"content":"<div class='slide'> <h1>The General Pattern</h1> <div class='pattern-table'> <h3>Any Circular Quantity Can Be Embedded!</h3> <table> <thead> <tr> <th>Wraparound Quantity</th> <th>Traditional Problems</th> <th>Embedding Solution</th> <th>Benefits</th> </tr> </thead> <tbody> <tr> <td><strong>Angle</strong><br>Œ∏ ‚àà [0, 2œÄ)</td> <td>Gimbal lock, discontinuities</td> <td>(cos Œ∏, sin Œ∏) ‚àà ‚Ñù¬≤</td> <td>Smooth interpolation</td> </tr> <tr> <td><strong>Time of Day</strong><br>t ‚àà [0, 24)</td> <td>Midnight wraparound</td> <td>(cos 2œÄt/24, sin 2œÄt/24)</td> <td>No special cases</td> </tr> <tr> <td><strong>Day of Week</strong><br>d ‚àà {0..6}</td> <td>Weekend averaging</td> <td>e^(2œÄid/7) or 7D one-hot</td> <td>Correct statistics</td> </tr> <tr> <td><strong>Phase</strong><br>œÜ ‚àà [-œÄ, œÄ)</td> <td>Phase unwrapping</td> <td>e^(iœÜ) ‚àà ‚ÑÇ</td> <td>Natural operations</td> </tr> <tr> <td><strong>Encoder Position</strong><br>n ‚àà [0, 4096)</td> <td>Rollover detection</td> <td>(cos 2œÄn/4096, sin 2œÄn/4096)</td> <td>Continuous tracking</td> </tr> </tbody> </table> </div> <div class='universal-class'> <h3>One Class to Rule Them All</h3> <pre><code class=\"language-python\">class CircularQuantity:\n    \"\"\"Universal handler for any quantity that wraps around\"\"\"\n    \n    def __init__(self, value, period):\n        self.period = period\n        self.value = value % period  # Normalize to [0, period)\n        \n        # THE KEY: Embed on unit circle\n        theta = 2 * np.pi * self.value / period\n        self.vec = np.array([np.cos(theta), np.sin(theta)])\n    \n    def shortest_distance_to(self, other):\n        \"\"\"Always returns shortest signed distance\"\"\"\n        angle = np.arctan2(\n            self.vec[0] * other.vec[1] - self.vec[1] * other.vec[0],\n            self.vec[0] * other.vec[0] + self.vec[1] * other.vec[1]\n        )\n        return angle * self.period / (2 * np.pi)\n    \n    def average_with(self, others):\n        \"\"\"Proper circular mean\"\"\"\n        all_vecs = [self.vec] + [o.vec for o in others]\n        mean_vec = np.mean(all_vecs, axis=0)\n        mean_vec /= np.linalg.norm(mean_vec)  # Renormalize\n        \n        angle = np.arctan2(mean_vec[1], mean_vec[0])\n        mean_value = angle * self.period / (2 * np.pi)\n        return CircularQuantity(mean_value, self.period)\n    \n    def interpolate_to(self, other, t):\n        \"\"\"Smooth interpolation along shortest path\"\"\"\n        # SLERP for perfect circular interpolation\n        dot = np.dot(self.vec, other.vec)\n        omega = np.arccos(np.clip(dot, -1, 1))\n        \n        if abs(omega) < 1e-10:  # Vectors are identical\n            return self\n        \n        vec_t = (np.sin((1-t)*omega)/np.sin(omega) * self.vec +\n                 np.sin(t*omega)/np.sin(omega) * other.vec)\n        \n        angle = np.arctan2(vec_t[1], vec_t[0])\n        value = angle * self.period / (2 * np.pi)\n        return CircularQuantity(value, self.period)</code></pre> </div> <div class='examples-grid'> <div class='example'> <h4>üìê Angles</h4> <pre><code>a1 = CircularQuantity(350, 360)\na2 = CircularQuantity(10, 360)\ndist = a1.shortest_distance_to(a2)\n# Result: 20¬∞</code></pre> </div> <div class='example'> <h4>‚è∞ Time</h4> <pre><code>t1 = CircularQuantity(23.5, 24)\nt2 = CircularQuantity(0.5, 24)\navg = t1.average_with([t2])\n# Result: 0.0 (midnight)</code></pre> </div> <div class='example'> <h4>üìÖ Weekdays</h4> <pre><code>days = [CircularQuantity(6, 7),  # Sat\n        CircularQuantity(0, 7),  # Sun\n        CircularQuantity(1, 7)]  # Mon\navg = days[0].average_with(days[1:])\n# Result: 0 (Sunday)</code></pre> </div> <div class='example'> <h4>üîÑ Encoder</h4> <pre><code>e1 = CircularQuantity(4090, 4096)\ne2 = CircularQuantity(10, 4096)\ndelta = e1.shortest_distance_to(e2)\n# Result: 20 counts</code></pre> </div> </div> </div> ","title":"The General Pattern"},{"content":"<div class='slide'> <h1>The Mathematical Insight</h1> <div class='info-box'> <h3>Why Does This Work?</h3> <div class='visual-demo'> <svg width='600' height='150' viewBox='0 0 600 150'> <!-- Line with endpoints --> <g transform='translate(100, 75)'> <line x1='-60' y1='0' x2='60' y2='0' stroke='#333' stroke-width='3'/> <circle cx='-60' cy='0' r='6' fill='#FF5722'/> <circle cx='60' cy='0' r='6' fill='#FF5722'/> <text x='0' y='30' text-anchor='middle' font-size='14' fill='#FFC107'>Line has endpoints</text> </g> <!-- vs --> <text x='300' y='80' text-anchor='middle' font-size='20' fill='#FFC107'>vs</text> <!-- Circle --> <g transform='translate(500, 40)'> <circle cx='0' cy='0' r='50' fill='none' stroke='#333' stroke-width='3'/> <text x='0' y='70' text-anchor='middle' font-size='14' fill='#FFC107'>Circle has none!</text> </g> </svg> </div> <p class='text-center'>A circle (S¬π) is topologically different from a line segment. Linear math breaks at the wraparound point.</p> </div> <div class='two-column-equal'> <div class='card'> <h3>üåê The Circle Problem</h3> <ul> <li><strong>Circles have no 'beginning' or 'end'</strong></li> <li>359¬∞ and 1¬∞ are neighbors</li> <li>But arithmetic says 359 - 1 = 358 ü§¶</li> <li>‚Üí Solution: Use 2D vectors instead!</li> </ul> </div> <div class='card'> <h3>üîÑ The Wrapping Function</h3> <svg width='300' height='120' viewBox='0 0 300 120'> <path d='M 20 80 Q 70 20, 120 80 T 220 80 T 280 80' stroke='#2196F3' stroke-width='3' fill='none'/> <text x='50' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>0¬∞</text> <text x='120' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>360¬∞</text> <text x='190' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>720¬∞</text> <text x='260' y='60' text-anchor='middle' font-size='12' fill='#FFC107'>1080¬∞</text> </svg> <p>Angles wrap around: 370¬∞ = 10¬∞, 730¬∞ = 10¬∞, etc. The infinite line wraps onto the finite circle.</p> </div> </div> <div class='success-box'> <h3>üîë The Universal Pattern</h3> <div class='process-flow'> <div class='process-step'> <h4>Problem Space</h4> <p>Non-linear manifold</p> <small>(circle, sphere, torus)</small> </div> <div class='process-step'> <h4>Embedding</h4> <p>Lift to linear space</p> <small>(‚Ñù¬≤, ‚Ñù¬≥, ‚ÑÇ)</small> </div> <div class='process-step'> <h4>Computation</h4> <p>Do linear algebra</p> <small>(add, average, interpolate)</small> </div> <div class='process-step'> <h4>Projection</h4> <p>Map back to manifold</p> <small>(atan2, normalize)</small> </div> </div> </div> <div class='two-column'> <div class='warning-box'> <h3>üéØ Where Else This Appears</h3> <ul> <li><strong>Quaternions:</strong> 3D rotations in 4D space</li> <li><strong>Complex Numbers:</strong> 2D rotations in ‚ÑÇ</li> <li><strong>Fourier Transform:</strong> Signals on unit circle</li> <li><strong>Neural Networks:</strong> Learned embeddings</li> </ul> </div> <div class='highlight-box'> <h3>üí≠ Mathematical Insight</h3> <blockquote style='font-style: italic; margin: 10px 0;'> 'The introduction of numbers as coordinates is an act of violence.' <br><cite style='font-size: 14px;'>‚Äî Hermann Weyl</cite> </blockquote> <p><strong>But sometimes, the right coordinates make the violence worthwhile!</strong></p> </div> </div> </div> ","title":"The Mathematical Insight"},{"content":"<div class='slide'> <h1>The Missing Math Class: Circular Operations</h1> <div class='warning-box'> <h3>ü§Ø What They Never Taught You</h3> <p>Circular quantities are everywhere, but traditional math classes skip the operations entirely! Here's what you can actually <strong>do</strong> once you embed them as vectors:</p> </div> <div class='two-column-equal'> <div class='card'> <h3>üìä Basic Operations</h3> <div class='operation-list'> <div class='op-item'> <strong>Addition:</strong> <code>v‚ÇÅ + v‚ÇÇ</code><br> <small>Compose two rotations</small> </div> <div class='op-item'> <strong>Subtraction:</strong> <code>v‚ÇÅ - v‚ÇÇ</code><br> <small>Find angular difference</small> </div> <div class='op-item'> <strong>Average:</strong> <code>mean(vectors)</code><br> <small>Circular mean (always works!)</small> </div> <div class='op-item'> <strong>Interpolation:</strong> <code>slerp(v‚ÇÅ, v‚ÇÇ, t)</code><br> <small>Smooth rotation between angles</small> </div> </div> </div> <div class='card'> <h3>üßÆ Advanced Operations</h3> <div class='operation-list'> <div class='op-item'> <strong>Distance:</strong> <code>shortest_path(Œ∏‚ÇÅ, Œ∏‚ÇÇ)</code><br> <small>Minimal angular separation</small> </div> <div class='op-item'> <strong>Scaling:</strong> <code>scalar √ó vector</code><br> <small>Scale magnitude, preserve direction</small> </div> <div class='op-item'> <strong>Derivatives:</strong> <code>d/dt [cos(œât), sin(œât)]</code><br> <small>Angular velocity vectors</small> </div> <div class='op-item'> <strong>Integration:</strong> <code>‚à´ œâ(t) dt</code><br> <small>Accumulate rotations over time</small> </div> </div> </div> </div> <div class='success-box'> <h3>üìà Circular Statistics (The Really Cool Stuff)</h3> <div class='code-example'> <pre><code class=\"language-python\"># Operations that actually work on circular data!\nangles = [350¬∞, 10¬∞, 5¬∞, 355¬∞]  # Wind directions\nvectors = [to_vector(Œ∏) for Œ∏ in angles]\n\n# Circular mean (not 180¬∞!)\nmean_vector = np.mean(vectors, axis=0) \nmean_angle = from_vector(mean_vector)  # ‚âà 0¬∞\n\n# Circular standard deviation  \ndispersion = 1 - |mean_vector|  # How \"spread out\" are they?\n\n# Circular correlation\ncorrelation = correlate_circular(wind_dir, wave_dir)\n\n# Circular regression (yes, this exists!)\nslope, intercept = circular_regression(time, wave_directions)</code></pre> </div> </div> <div class='info-box'> <h3>üéØ Why This Matters</h3> <div class='three-column'> <div> <h4>üåä Oceanography</h4> <p>Wave directions, current flows</p> </div> <div> <h4>üß≠ Navigation</h4> <p>GPS, compass bearings, flight paths</p> </div> <div> <h4>üß¨ Biology</h4> <p>Circadian rhythms, animal migration</p> </div> <div> <h4>üéµ Signal Processing</h4> <p>Phase analysis, Fourier transforms</p> </div> <div> <h4>ü§ñ Robotics</h4> <p>Joint angles, orientation control</p> </div> <div> <h4>üìä Data Science</h4> <p>Seasonal trends, cyclic patterns</p> </div> </div> </div> <div class='highlight-box'> <h3>üí° The Big Insight</h3> <p><strong>Every operation you know from linear algebra works on circular quantities‚Äîyou just need to embed them first!</strong> This is why embedding is such a powerful mathematical technique.</p> <div class='formula-showcase'> <code>Circular Quantity ‚Üí Vector ‚Üí Linear Operation ‚Üí Vector ‚Üí Circular Result</code> </div> </div> </div>","title":"The Missing Math Class: Circular Operations"},{"content":"<div class='slide'> <h1>Circular Statistics: The Hidden Superpower</h1> <div class='warning-box'> <h3>ü§Ø What Statistics Class Never Taught You</h3> <p>Standard statistics breaks horribly on circular data. But vector embedding makes circular statistics <strong>trivially easy</strong>‚Äîand incredibly powerful!</p> </div> <div class='two-column-equal'> <div class='card'> <h3>üìä The Problem with Regular Stats</h3> <div class='code-example'> <pre><code class=\"language-python\"># Wind directions (degrees)\nangles = [350, 10, 5, 355]\n\n# Regular mean = DISASTER\nmean = sum(angles) / len(angles)  # = 180¬∞\n# 180¬∞ is the OPPOSITE direction! ü§¶‚Äç‚ôÇÔ∏è\n\n# Regular standard deviation = MEANINGLESS\nstd = numpy.std(angles)  # = 187¬∞\n# Standard deviation larger than the range!</code></pre> </div> </div> <div class='card'> <h3>‚ú® Vector Statistics = Magic</h3> <div class='code-example'> <pre><code class=\"language-python\"># Convert to vectors\nvectors = [angle_to_vector(Œ∏) for Œ∏ in angles]\n\n# Circular mean = WORKS!\nmean_vector = np.mean(vectors, axis=0)\nmean_angle = vector_to_angle(mean_vector)  # ‚âà 0¬∞\n# Correct direction! üéØ\n\n# Circular standard deviation\nR = |mean_vector|  # Mean vector length\ncircular_std = sqrt(-2 * log(R))  # ‚âà 22¬∞\n# Sensible measure of spread!</code></pre> </div> </div> </div> <div class='info-box'> <h3>üß† The Key Insight: Mean Vector Length</h3> <div class='two-column'> <div class='visual-element'> <svg width='300' height='200' viewBox='0 0 300 200'> <!-- Tight cluster --> <g transform='translate(75, 100)'> <circle r='50' fill='none' stroke='#666' stroke-width='1' opacity='0.3'/> <!-- Data points clustered tightly --> <circle cx='45' cy='5' r='4' fill='#4CAF50'/> <circle cx='47' cy='-3' r='4' fill='#4CAF50'/> <circle cx='43' cy='3' r='4' fill='#4CAF50'/> <circle cx='46' cy='0' r='4' fill='#4CAF50'/> <!-- Strong mean vector --> <path d='M 0 0 L 40 0' stroke='#FF5722' stroke-width='4' marker-end='url(#arrow)'/> <text x='0' y='-65' text-anchor='middle' fill='#4CAF50' font-size='12'>Tight Cluster</text> <text x='0' y='75' text-anchor='middle' fill='#FF5722' font-size='11'>|R| ‚âà 0.95</text> <text x='0' y='87' text-anchor='middle' fill='#666' font-size='10'>Low variance</text> </g> <!-- Spread out data --> <g transform='translate(225, 100)'> <circle r='50' fill='none' stroke='#666' stroke-width='1' opacity='0.3'/> <!-- Data points spread out --> <circle cx='45' cy='5' r='4' fill='#2196F3'/> <circle cx='-30' cy='35' r='4' fill='#2196F3'/> <circle cx='-15' cy='-45' r='4' fill='#2196F3'/> <circle cx='20' cy='-40' r='4' fill='#2196F3'/> <!-- Weak mean vector --> <path d='M 0 0 L 8 -5' stroke='#FF5722' stroke-width='4' marker-end='url(#arrow)'/> <text x='0' y='-65' text-anchor='middle' fill='#2196F3' font-size='12'>Spread Out</text> <text x='0' y='75' text-anchor='middle' fill='#FF5722' font-size='11'>|R| ‚âà 0.1</text> <text x='0' y='87' text-anchor='middle' fill='#666' font-size='10'>High variance</text> </g> <defs> <marker id='arrow' markerWidth='10' markerHeight='7' refX='10' refY='3.5' orient='auto'> <polygon points='0 0, 10 3.5, 0 7' fill='#FF5722'/> </marker> </defs> </svg> </div> <div> <h4>üí° The Beautiful Truth</h4> <div class='formula-showcase'> <p><strong>Tight cluster:</strong> Mean vector is long (|R| ‚Üí 1)</p> <p><strong>Spread out:</strong> Mean vector is short (|R| ‚Üí 0)</p> <p><strong>Uniform circle:</strong> Mean vector ‚âà 0</p> </div> <p>The length of the mean vector automatically captures how 'concentrated' your circular data is!</p> </div> </div> </div> <div class='success-box'> <h3>üî¨ Advanced Circular Stats That Actually Work</h3> <div class='code-example'> <pre><code class=\"language-python\"># Circular correlation between two angular variables\ndef circular_correlation(angles1, angles2):\n    v1 = [angle_to_vector(Œ∏) for Œ∏ in angles1]\n    v2 = [angle_to_vector(Œ∏) for Œ∏ in angles2]\n    # Standard correlation on the vector components\n    return pearsonr(v1, v2)\n\n# Circular regression (yes, this exists!)\ndef circular_regression(x, circular_y):\n    vectors_y = [angle_to_vector(Œ∏) for Œ∏ in circular_y]\n    # Regress each component separately\n    cos_model = LinearRegression().fit(x, [v[0] for v in vectors_y])\n    sin_model = LinearRegression().fit(x, [v[1] for v in vectors_y])\n    return cos_model, sin_model\n\n# Watson-Williams test (circular ANOVA)\n# Test if multiple groups have the same mean direction\ndef watson_williams_test(group1_angles, group2_angles):\n    # Convert to vectors, compute mean directions, test significance\n    # (This is the circular equivalent of a t-test!)</code></pre> </div> </div> <div class='highlight-box'> <h3>üåü Real-World Applications</h3> <div class='three-column'> <div> <h4>üß¨ Biology</h4> <p><strong>Animal migration:</strong> Test if birds change direction by season</p> <p><strong>Circadian rhythms:</strong> Correlate activity with time of day</p> </div> <div> <h4>üåä Earth Sciences</h4> <p><strong>Wind patterns:</strong> Seasonal wind direction changes</p> <p><strong>Ocean currents:</strong> Correlation with tidal cycles</p> </div> <div> <h4>üéµ Signal Processing</h4> <p><strong>Phase analysis:</strong> Correlation between signal phases</p> <p><strong>Circular convolution:</strong> Periodic signal filtering</p> </div> </div> </div> </div>","title":"Circular Statistics: The Hidden Superpower"},{"content":"<div class='slide'> <h1>Discrete Calculus on Circles: Data-Driven Operations</h1> <div class='info-box'> <h3>üìä Real-World Data = Discrete Samples</h3> <p>In practice, we don't have continuous functions‚Äîwe have <strong>time series data</strong> of circular quantities. How do we compute derivatives and integrals when our data wraps around?</p> </div> <div class='two-column-equal'> <div class='card'> <h3>üìà Discrete Derivatives (Angular Velocity)</h3> <div class='code-example'> <pre><code class=\"language-python\"># WRONG: Naive difference breaks at wraparound\nangles = [358¬∞, 359¬∞, 1¬∞, 2¬∞]  # Smooth rotation\nnaive_diff = [1¬∞, 2¬∞, -357¬∞]  # HUGE SPIKE! üí•\n\n# RIGHT: Vector space derivative\nvectors = [(cos(Œ∏), sin(Œ∏)) for Œ∏ in angles]\ndvdt = [(v[i+1] - v[i])/dt for i in range(len(v)-1)]\n\n# Angular velocity from vector derivative\nœâ = cross_product(v[i], dvdt[i]) / |v[i]|¬≤\n# Result: [1¬∞/s, 1¬∞/s, 1¬∞/s] ‚úÖ</code></pre> </div> </div> <div class='card'> <h3>üìâ Discrete Integrals (Accumulated Rotation)</h3> <div class='code-example'> <pre><code class=\"language-python\"># WRONG: Sum angles directly\nangular_velocities = [90¬∞/s, 90¬∞/s, 90¬∞/s, 90¬∞/s]\nnaive_sum = sum(angular_velocities) * dt  # 360¬∞???\n\n# RIGHT: Accumulate in vector space\nv_accumulated = [1, 0]  # Start at 0¬∞\nfor œâ in angular_velocities:\n    # Rotate vector by angular increment\n    dŒ∏ = œâ * dt\n    rotation = [[cos(dŒ∏), -sin(dŒ∏)],\n                [sin(dŒ∏), cos(dŒ∏)]]\n    v_accumulated = rotation @ v_accumulated\n\nfinal_angle = atan2(v_accumulated)  # Correct!</code></pre> </div> </div> </div> <div class='success-box'> <h3>üîß Practical Applications in Data Science</h3> <div class='two-column'> <div> <h4>üåä Wind Speed Analysis</h4> <div class='code-example'> <pre><code class=\"language-python\"># Wind direction time series (sampled every hour)\nwind_dirs = [350¬∞, 355¬∞, 0¬∞, 5¬∞, 10¬∞]  # North-ish\nwind_speeds = [10, 12, 15, 14, 11]  # mph\n\n# Compute wind vector components\nu = [-speed * sin(dir) for speed, dir in zip(wind_speeds, wind_dirs)]\nv = [-speed * cos(dir) for speed, dir in zip(wind_speeds, wind_dirs)]\n\n# Now can compute proper derivatives!\ndu_dt = np.gradient(u)  # Wind acceleration (east)\ndv_dt = np.gradient(v)  # Wind acceleration (north)</code></pre> </div> </div> <div> <h4>ü§ñ Robot Heading Tracking</h4> <div class='code-example'> <pre><code class=\"language-python\"># IMU gives heading samples at 100Hz\nheadings = sensor.get_heading_buffer()  # [Œ∏‚ÇÅ, Œ∏‚ÇÇ, ..., Œ∏‚Çô]\ndt = 0.01  # 10ms between samples\n\n# Convert to unit vectors\nvectors = [(cos(h), sin(h)) for h in headings]\n\n# Compute angular velocity using discrete derivative\nangular_vel = []\nfor i in range(len(vectors)-1):\n    # Cross product gives rotation rate\n    œâ = (vectors[i][0]*vectors[i+1][1] - \n         vectors[i][1]*vectors[i+1][0]) / dt\n    angular_vel.append(œâ)\n\n# Smooth using windowed average (no wraparound issues!)\nsmoothed_œâ = moving_average(angular_vel, window=10)</code></pre> </div> </div> </div> </div> <div class='warning-box'> <h3>‚ö†Ô∏è Common Pitfalls with Discrete Circular Data</h3> <div class='three-column'> <div> <h4>‚ùå Phase Unwrapping</h4> <p><code>unwrap([350¬∞, 10¬∞])</code> ‚Üí <code>[350¬∞, 370¬∞]</code></p> <p>Creates artificial trends! Use vectors instead.</p> </div> <div> <h4>‚ùå Modulo Arithmetic</h4> <p><code>(Œ∏‚ÇÇ - Œ∏‚ÇÅ) % 360</code></p> <p>Loses direction info. Vector difference preserves it.</p> </div> <div> <h4>‚ùå Averaging Raw Angles</h4> <p><code>mean([0¬∞, 90¬∞, 180¬∞, 270¬∞])</code> ‚Üí <code>135¬∞</code></p> <p>Should be undefined! Vector mean ‚Üí 0.</p> </div> </div> </div> <div class='highlight-box'> <h3>üéØ The Key Pattern for Discrete Operations</h3> <div class='formula-showcase'> <div style='text-align: center; padding: 20px;'> <p style='font-size: 18px; margin: 10px 0;'> <strong>Discrete Samples</strong> ‚Üí <strong>Vector Time Series</strong> ‚Üí <strong>Standard Numpy Operations</strong> ‚Üí <strong>Interpret Results</strong> </p> <p style='margin-top: 20px;'> <code>Œ∏[t]</code> ‚Üí <code>[cos(Œ∏[t]), sin(Œ∏[t])]</code> ‚Üí <code>np.gradient(), np.cumsum()</code> ‚Üí <code>atan2() if needed</code> </p> </div> </div> <p><strong>Bottom Line:</strong> NumPy/Pandas operations 'just work' on vector representations‚Äîno special circular functions needed!</p> </div> </div>","title":"Discrete Calculus on Circles: Data-Driven Operations"},{"content":"<div class='slide flight-photo'> <style> .flight-photo { padding: 2.5vh 3vw; display: flex; flex-direction: column; gap: 2vh; } .flight-photo h2 { text-align: center; margin-bottom: 1vh; background: linear-gradient(135deg, #ff6b6b, #4ecdc4); -webkit-background-clip: text; background-clip: text; color: transparent; font-size: clamp(24px, 3.5vw, 42px); } .bottom-hint { margin-top: 2vh; text-align: center; } .hint-button { background: rgba(255, 255, 255, 0.06); color: #f0f6fc; border: 1px solid rgba(255, 255, 255, 0.12); border-radius: 10px; padding: 8px 12px; font-weight: 600; font-size: 0.9em; cursor: pointer; transition: all 0.3s; opacity: 0.7; } .hint-button:hover { background: rgba(255, 255, 255, 0.12); transform: translateY(-2px); opacity: 1; } .hint-content { margin-top: 1vh; padding: 1vh 1.5vw; background: rgba(255, 255, 255, 0.03); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px; color: #f0f6fc; line-height: 1.5; font-size: 0.85em; text-align: left; max-width: 500px; margin-left: auto; margin-right: auto; } .hint-content ul { margin: 0.5vh 0; padding-left: 2em; } .method-difference { background: rgba(255, 87, 34, 0.15); border: 2px solid rgba(255, 87, 34, 0.5); border-radius: 8px; padding: 1.5vh 1.5vw; margin-top: 1.5vh; animation: pulse 2s ease-in-out infinite; } @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.9; } } .method-difference h4 { margin: 0 0 0.5vh 0; color: #ff5722; font-size: 1.1em; } .method-difference p { margin: 0; color: #f0f6fc; line-height: 1.4; } .main-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 2vw; flex: 1; } .panel { background: rgba(255, 255, 255, 0.03); border-radius: 12px; padding: 2vh 2vw; border: 1px solid rgba(255, 255, 255, 0.1); display: flex; flex-direction: column; gap: 1.5vh; position: relative; } .panel h3 { margin: 0; color: #4ecdc4; font-size: 1.2em; } .controls { display: flex; flex-direction: column; gap: 1vh; } .control-row { display: flex; align-items: center; gap: 1vw; } .control-row label { flex: 0 0 120px; font-size: 0.85em; color: #f0f6fc; } .control-row input[type='range'] { flex: 1; background: rgba(255, 255, 255, 0.1); outline: none; height: 6px; border-radius: 3px; cursor: pointer; } .control-row .value { flex: 0 0 80px; text-align: right; font-family: monospace; color: #4ecdc4; font-weight: bold; } .clock-container { display: flex; justify-content: space-between; align-items: center; flex: 1; gap: 1vw; margin: 2vh 0; } .clock-viz { text-align: center; } .clock-viz svg { width: 320px; height: 320px; } .clock-label { font-size: 0.85em; color: #7d8590; margin-top: 0.5vh; } .vector-viz { display: flex; justify-content: center; align-items: center; flex: 1; min-height: 300px; } .vector-viz svg { width: 100%; height: 100%; min-height: 350px; max-height: 450px; } .time-toggle { position: absolute; top: 2vh; right: 2vw; background: rgba(255, 255, 255, 0.06); color: #f0f6fc; border: 1px solid rgba(255, 255, 255, 0.12); border-radius: 6px; padding: 6px 12px; font-size: 0.85em; cursor: pointer; transition: all 0.2s; z-index: 10; } .time-toggle:hover { background: rgba(255, 255, 255, 0.12); } .flight-span-label { text-align: center; font-size: 0.9em; color: #FFC107; font-weight: bold; margin-top: -1vh; } .results { display: grid; grid-template-columns: 1fr 1fr; gap: 1vw; margin-top: 1vh; } .result-card { background: rgba(255, 255, 255, 0.02); border-radius: 8px; padding: 1vh 1vw; border: 1px solid rgba(255, 255, 255, 0.1); } .result-card.good { border-color: #4caf50; background: rgba(76, 175, 80, 0.1); } .result-card.bad { border-color: #ff5722; background: rgba(255, 87, 34, 0.1); } .result-label { font-size: 0.8em; color: #7d8590; margin-bottom: 0.3vh; } .result-value { font-size: 1.1em; font-weight: bold; } .photo-windows { position: absolute; inset: 0; pointer-events: none; } .explanation { background: rgba(78, 205, 196, 0.1); border: 1px solid rgba(78, 205, 196, 0.3); border-radius: 8px; padding: 1vh 1.5vw; margin-top: 1vh; font-size: 0.9em; line-height: 1.4; } .explanation strong { color: #4ecdc4; } </style> <h2>üõ©Ô∏è Aerial Photography: Finding Optimal Light Windows</h2> <div class='main-grid'> <div class='panel'> <h3>Flight Parameters</h3> <div class='controls'> <div class='control-row'> <label>Departure (Local):</label> <input type='range' id='departure-time' min='0' max='23.75' step='0.25' value='6' /> <span class='value' id='departure-value'>06:00</span> </div> <div class='control-row'> <label>Flight Duration:</label> <input type='range' id='flight-duration' min='1' max='12' step='0.5' value='5' /> <span class='value' id='duration-value'>5.0h</span> </div> <div class='control-row'> <label>Timezones Crossed:</label> <input type='range' id='timezones' min='-12' max='12' step='1' value='3' /> <span class='value' id='timezone-value'>+3h</span> </div> </div> <div class='clock-container'> <div class='clock-viz'> <svg id='departure-clock' viewBox='0 0 200 200'> <circle cx='100' cy='100' r='80' fill='none' stroke='#333' stroke-width='2' /> <g class='photo-windows'></g> <line id='dep-hand' x1='100' y1='100' x2='100' y2='30' stroke='#2196F3' stroke-width='4' stroke-linecap='round' /> <circle cx='100' cy='100' r='5' fill='#fff' /> <text x='100' y='10' text-anchor='middle' fill='#7d8590' font-size='12' > 00 </text> <text x='180' y='105' text-anchor='middle' fill='#7d8590' font-size='12' > 06 </text> <text x='100' y='195' text-anchor='middle' fill='#7d8590' font-size='12' > 12 </text> <text x='20' y='105' text-anchor='middle' fill='#7d8590' font-size='12' > 18 </text> </svg> <div class='clock-label'>Departure</div> </div> <div class='clock-viz'> <svg id='arrival-clock' viewBox='0 0 200 200'> <circle cx='100' cy='100' r='80' fill='none' stroke='#333' stroke-width='2' /> <g class='photo-windows'></g> <line id='arr-hand' x1='100' y1='100' x2='100' y2='30' stroke='#4CAF50' stroke-width='4' stroke-linecap='round' /> <circle cx='100' cy='100' r='5' fill='#fff' /> <text x='100' y='10' text-anchor='middle' fill='#7d8590' font-size='12' > 00 </text> <text x='180' y='105' text-anchor='middle' fill='#7d8590' font-size='12' > 06 </text> <text x='100' y='195' text-anchor='middle' fill='#7d8590' font-size='12' > 12 </text> <text x='20' y='105' text-anchor='middle' fill='#7d8590' font-size='12' > 18 </text> </svg> <div class='clock-label'>Arrival (Local)</div> </div> </div> <div class='explanation'> <strong>Photo Windows:</strong> <span style='color: #FF9800;'>Morning golden hour (9-11 AM)</span> and <span style='color: #2196F3;'>afternoon window (2-4 PM)</span> shown as colored arcs. <span id='explanation-text' >Drag sliders to see how each method chooses a photo window.</span > </div> </div> <div class='panel'> <h3>Vector Embedding Space</h3> <button class='time-toggle' id='time-toggle'> 24h </button> <div class='vector-viz'> <svg id='vector-space' viewBox='0 0 400 400'> <!-- Unit circle --> <circle cx='200' cy='200' r='150' fill='none' stroke='#333' stroke-width='1' stroke-dasharray='2,2' opacity='0.5' /> <!-- Axes --> <line x1='50' y1='200' x2='350' y2='200' stroke='#333' stroke-width='1' opacity='0.3' /> <line x1='200' y1='50' x2='200' y2='350' stroke='#333' stroke-width='1' opacity='0.3' /> <!-- Time labels --> <text id='label-north' x='200' y='35' text-anchor='middle' fill='#7d8590' font-size='14'>00:00</text> <text id='label-east' x='365' y='205' text-anchor='middle' fill='#7d8590' font-size='14'>06:00</text> <text id='label-south' x='200' y='370' text-anchor='middle' fill='#7d8590' font-size='14'>12:00</text> <text id='label-west' x='35' y='205' text-anchor='middle' fill='#7d8590' font-size='14'>18:00</text> <!-- Photo window vectors (morning) --> <g id='morning-window'> <path id='morning-arc' fill='rgba(255, 152, 0, 0.2)' stroke='#FF9800' stroke-width='2' /> <text id='morning-label' x='240' y='60' text-anchor='middle' fill='#FF9800' font-size='11' font-weight='bold' > Morning </text> </g> <!-- Photo window vectors (afternoon) --> <g id='afternoon-window'> <path id='afternoon-arc' fill='rgba(33, 150, 243, 0.2)' stroke='#2196F3' stroke-width='2' /> <text id='afternoon-label' x='240' y='180' text-anchor='middle' fill='#2196F3' font-size='11' font-weight='bold' > Afternoon </text> </g> <!-- Departure vector --> <line id='dep-vector' x1='200' y1='200' x2='280' y2='200' stroke='#2196F3' stroke-width='3' /> <circle id='dep-point' cx='280' cy='200' r='5' fill='#2196F3' /> <text id='dep-label' x='280' y='190' text-anchor='middle' fill='#2196F3' font-size='11' > Departure </text> <!-- Arrival vector --> <line id='arr-vector' x1='200' y1='200' x2='280' y2='200' stroke='#4CAF50' stroke-width='3' /> <circle id='arr-point' cx='280' cy='200' r='5' fill='#4CAF50' /> <text id='arr-label' x='280' y='190' text-anchor='middle' fill='#4CAF50' font-size='11' > Arrival </text> <!-- Distance arc --> <path id='distance-arc' fill='none' stroke='#FFC107' stroke-width='2' stroke-dasharray='3,3' opacity='0.8' /> </svg> </div> <div class='flight-span-label'> <span id='distance-label'></span> </div> <div class='results'> <div class='result-card' id='naive-result'> <div class='result-label'>‚ùå Naive Calculation</div> <div class='result-value' id='naive-distance'>-</div> </div> <div class='result-card' id='vector-result'> <div class='result-label'>‚úÖ Vector Distance</div> <div class='result-value' id='vector-distance'>-</div> </div> <div class='result-card' id='morning-result'> <div class='result-label'>To Morning Window</div> <div class='result-value' id='morning-distance'>-</div> </div> <div class='result-card' id='photo-ready'> <div class='result-label'>Photo Quality</div> <div class='result-value' id='photo-quality'>-</div> </div> </div> </div> </div> <!-- Dynamic explanation that appears when methods disagree --> <div class='method-difference' id='method-difference' style='display: none' > <h4>üö® Methods Disagree! Here's Why:</h4> <p id='difference-explanation'></p> </div> <!-- Teaching hint at bottom --> <div class='bottom-hint'> <button class='hint-button' id='hint-button'> üí° Hint: How to break naive calculation </button> <div class='hint-content' id='hint-content' style='display: none'> <p><strong>Try this scenario:</strong></p> <ul> <li>Set Departure to <strong>17:00-19:00</strong> (evening)</li> <li>Set Flight Duration to <strong>3-5 hours</strong></li> <li>Set Timezones to <strong>-2 or -3</strong> (westward)</li> </ul> <p> This arrives around <strong>7-11 PM</strong>. The naive method says 'wait 10+ hours for morning' but vector embedding knows morning is actually <strong>closer</strong> going backwards on the clock! </p> </div> </div> </div> ","title":"Untitled Slide"},{"content":"<div class='slide'> <h1>Key Takeaways</h1> <div class='main-takeaway'> <h2>üéØ The Golden Rule</h2> <div class='golden-rule'> <p>When you see a quantity that wraps around,</p> <p><strong>ask: 'Can I embed this on a circle?'</strong></p> </div> </div> <div class='practical-steps'> <h3>Your Debugging Checklist</h3> <div class='checklist'> <div class='check-item'> <span class='checkbox'>‚úì</span> <div> <h4>Spot the Wraparound</h4> <p>Does your value jump discontinuously? (359¬∞ ‚Üí 0¬∞, 11:59 PM ‚Üí 12:00 AM)</p> </div> </div> <div class='check-item'> <span class='checkbox'>‚úì</span> <div> <h4>Identify the Period</h4> <p>What's the cycle length? (360¬∞ for angles, 24 hours for time, 7 for weekdays)</p> </div> </div> <div class='check-item'> <span class='checkbox'>‚úì</span> <div> <h4>Choose Your Embedding</h4> <p>Usually: <code style='display: inline-block;'>(cos(<span style='display: inline-block; vertical-align: middle;'><span style='display: block; text-align: center; border-bottom: 1px solid;'>2œÄx</span><span style='display: block; text-align: center;'>T</span></span>), sin(<span style='display: inline-block; vertical-align: middle;'><span style='display: block; text-align: center; border-bottom: 1px solid;'>2œÄx</span><span style='display: block; text-align: center;'>T</span></span>))</code> where <code>T</code> is the period</p> </div> </div> <div class='check-item'> <span class='checkbox'>‚úì</span> <div> <h4>Work in Vector Space</h4> <p>Do all math on the vectors, not the raw values</p> </div> </div> <div class='check-item'> <span class='checkbox'>‚úì</span> <div> <h4>Project Back When Needed</h4> <p>Use <code>atan2(y, x)</code> to recover the original quantity</p> </div> </div> </div> </div> <div class='libraries-section'> <h3>Don't Reinvent: Use Libraries!</h3> <div class='library-grid'> <div class='library'> <h4>Python</h4> <ul> <li><code>scipy.stats.circmean</code></li> <li><code>astropy.coordinates</code></li> <li><code>pyquaternion</code></li> </ul> </div> <div class='library'> <h4>JavaScript</h4> <ul> <li><code>d3-interpolate</code></li> <li><code>three.js Quaternion</code></li> <li><code>tinycolor2</code></li> </ul> </div> <div class='library'> <h4>C++</h4> <ul> <li><code>Eigen::AngleAxis</code></li> <li><code>boost::geometry</code></li> <li><code>tf2</code> (ROS)</li> </ul> </div> <div class='library'> <h4>MATLAB</h4> <ul> <li><code>circstat toolbox</code></li> <li><code>Aerospace Toolbox</code></li> <li><code>angle()</code>, <code>unwrap()</code></li> </ul> </div> </div> </div> <div class='red-flags'> <h3>üö© Red Flags in Your Code</h3> <div class='flag-list'> <div class='flag'> <code>if (angle > 180) angle -= 360;</code> <span>‚Üí Use circular math instead</span> </div> <div class='flag'> <code>if (crossed_midnight) /* special case */</code> <span>‚Üí Embed on 24-hour circle</span> </div> <div class='flag'> <code>while (phase > œÄ) phase -= 2œÄ;</code> <span>‚Üí Work with complex exponentials</span> </div> <div class='flag'> <code>// TODO: handle wraparound</code> <span>‚Üí Today's the day!</span> </div> </div> </div> <div class='success-story'> <div class='story-content'> <h3>üéâ Success Story</h3> <p>'After this talk, I fixed a 3-year-old GPS bearing bug in 5 lines of code. The robot finally drives in straight lines!'</p> <cite>‚Äî Future You</cite> </div> </div> </div> ","title":"Key Takeaways"},{"content":"<div class='slide'> <div class='questions-slide'> <h1>Questions?</h1> <div class='contact-info'> <div class='demo-offer'> <h3>üî¨ Want to See This in Action?</h3> <p>I've got interactive demos for:</p> <ul> <li>Live angle averaging visualization</li> <li>Color interpolation comparison</li> <li>Robot heading controller simulation</li> </ul> </div> <div class='resources'> <h3>üìö Resources</h3> <ul> <li><strong>Slides:</strong> Available on internal wiki</li> <li><strong>Code Examples:</strong> Python/JS implementations</li> <li><strong>Further Reading:</strong> 'Lie Groups for Computer Vision' by Ethan Eade</li> </ul> </div> </div> <div class='challenge'> <h3>üèÜ Challenge for Next Week</h3> <div class='challenge-box'> <p>Find ONE wraparound bug in your current codebase</p> <p>Try the embedding approach</p> <p>Share your results!</p> </div> </div> <div class='final-thought'> <blockquote> 'The best way to learn mathematics is to do mathematics.' <cite>‚Äî Paul Halmos</cite> </blockquote> <p>So go break some rings! üíç‚û°Ô∏èüìê</p> </div> <div class='thank-you'> <h2>Thank You!</h2> <div class='outro-visual'> <svg width='300' height='150' viewBox='0 0 300 150'> <!-- Circle with happy face --> <circle cx='150' cy='75' r='60' fill='none' stroke='#4CAF50' stroke-width='3'/> <!-- Happy eyes --> <circle cx='130' cy='60' r='5' fill='#4CAF50'/> <circle cx='170' cy='60' r='5' fill='#4CAF50'/> <!-- Happy smile --> <path d='M 120 90 Q 150 110 180 90' fill='none' stroke='#4CAF50' stroke-width='3'/> <!-- Surrounding points showing smooth embedding --> <g opacity='0.5'> <circle cx='90' cy='75' r='3' fill='#2196F3'/> <circle cx='210' cy='75' r='3' fill='#2196F3'/> <circle cx='150' cy='15' r='3' fill='#2196F3'/> <circle cx='150' cy='135' r='3' fill='#2196F3'/> <!-- Smooth curves connecting them --> <path d='M 90 75 Q 90 15, 150 15' fill='none' stroke='#2196F3' stroke-width='1' opacity='0.3'/> <path d='M 150 15 Q 210 15, 210 75' fill='none' stroke='#2196F3' stroke-width='1' opacity='0.3'/> <path d='M 210 75 Q 210 135, 150 135' fill='none' stroke='#2196F3' stroke-width='1' opacity='0.3'/> <path d='M 150 135 Q 90 135, 90 75' fill='none' stroke='#2196F3' stroke-width='1' opacity='0.3'/> </g> <text x='150' y='160' text-anchor='middle' font-size='12' fill='#666'> No more wraparound headaches! </text> </svg> </div> </div> </div> </div> ","title":"Questions?"}];

// Set up window.slideData for embedded mode compatibility
window.slideData = {};
slidesData.forEach((slide, index) => {
    window.slideData[index.toString()] = slide.content;
});

// This function contains all the logic for the aerial photography scheduling slide
// Shows why vector embedding matters for "time to optimal window" calculations

function initFlightPhotoWindow() {
  try {
    console.log("üì∏ Initializing Flight Photo Window demo...");

    // Get DOM elements
    const departureSlider = document.getElementById("departure-time");
    const durationSlider = document.getElementById("flight-duration");
    const timezonesSlider = document.getElementById("timezones");

    const departureValue = document.getElementById("departure-value");
    const durationValue = document.getElementById("duration-value");
    const timezoneValue = document.getElementById("timezone-value");

    const depClock = document.getElementById("departure-clock");
    const arrClock = document.getElementById("arrival-clock");
    const depHand = document.getElementById("dep-hand");
    const arrHand = document.getElementById("arr-hand");

    const vectorSpace = document.getElementById("vector-space");
    const depVector = document.getElementById("dep-vector");
    const arrVector = document.getElementById("arr-vector");
    const depPoint = document.getElementById("dep-point");
    const arrPoint = document.getElementById("arr-point");
    const depLabel = document.getElementById("dep-label");
    const arrLabel = document.getElementById("arr-label");

    const distanceArc = document.getElementById("distance-arc");
    const distanceLabel = document.getElementById("distance-label");

    // Time toggle button and labels
    const timeToggle = document.getElementById("time-toggle");
    const labelNorth = document.getElementById("label-north");
    const labelEast = document.getElementById("label-east");
    const labelSouth = document.getElementById("label-south");
    const labelWest = document.getElementById("label-west");
    let isMilitaryTime = true;

    const naiveDistance = document.getElementById("naive-distance");
    const vectorDistance = document.getElementById("vector-distance");
    const morningDistance = document.getElementById("morning-distance");
    const photoQuality = document.getElementById("photo-quality");

    const naiveResult = document.getElementById("naive-result");
    const vectorResult = document.getElementById("vector-result");
    const morningResult = document.getElementById("morning-result");
    const photoReady = document.getElementById("photo-ready");

    // Pedagogical elements
    const hintButton = document.getElementById("hint-button");
    const hintContent = document.getElementById("hint-content");
    const methodDifference = document.getElementById("method-difference");
    const differenceExplanation = document.getElementById(
      "difference-explanation"
    );
    const explanationText = document.getElementById("explanation-text");

    // Photo windows (in 24h format)
    const MORNING_START = 9; // 9 AM
    const MORNING_END = 11; // 11 AM
    const AFTERNOON_START = 14; // 2 PM
    const AFTERNOON_END = 16; // 4 PM

    // THE KEY FUNCTION: Embed time-of-day as 2D vector
    function embedTimeAsVector(hours) {
      // Convert to clock position:
      // - 0 hours (midnight) should be at top (angle = -œÄ/2 in standard coords)
      // - Hours increase clockwise
      const theta = (2 * Math.PI * hours) / 24 - Math.PI / 2;
      return {
        x: Math.cos(theta),
        y: Math.sin(theta),
        angle: theta,
      };
    }

    // Compute circular distance between two times (in hours)
    function circularDistance(hours1, hours2) {
      const vec1 = embedTimeAsVector(hours1);
      const vec2 = embedTimeAsVector(hours2);

      // Dot product gives us cos(angle between)
      const dotProduct = vec1.x * vec2.x + vec1.y * vec2.y;
      const angleDistance = Math.acos(Math.max(-1, Math.min(1, dotProduct)));

      // Convert radians to hours
      return (angleDistance * 12) / Math.PI;
    }

    // NAIVE distance calculation (what most systems do wrong)
    function naiveTimeDistance(currentTime, targetWindow) {
      // Most flight planning software does this simple subtraction
      let distance = targetWindow - currentTime;

      // Handle negative by adding 24 (but this is where it goes wrong!)
      if (distance < 0) {
        distance += 24;
      }

      // This gives you "hours until next occurrence" but not shortest distance!
      return distance;
    }

    // Find OPTIMAL photo window - this is where embedding shines!
    function findOptimalWindow(arrivalTime) {
      // Check all windows and find the best one
      const windows = [
        { start: MORNING_START, end: MORNING_END, name: "Morning" },
        { start: AFTERNOON_START, end: AFTERNOON_END, name: "Afternoon" },
      ];

      let bestWindow = null;
      let shortestWait = 24;

      // Naive approach - find the CHRONOLOGICALLY NEXT window
      let naiveChoice = null;
      let naiveWait = 24;

      // First, try to find a window later today
      for (const window of windows) {
        const windowCenter = (window.start + window.end) / 2;

        if (windowCenter > arrivalTime) {
          const waitTime = windowCenter - arrivalTime;
          if (waitTime < naiveWait) {
            naiveWait = waitTime;
            naiveChoice = window;
          }
        }
      }

      // If no window found later today, pick the earliest tomorrow
      if (!naiveChoice) {
        // Morning comes first tomorrow
        naiveChoice = windows[0]; // Morning window
        naiveWait = (MORNING_START + MORNING_END) / 2 + 24 - arrivalTime;
      }

      // Vector embedding approach - finds TRUE shortest distance in either direction
      for (const window of windows) {
        const windowCenter = (window.start + window.end) / 2;
        const vectorDist = circularDistance(arrivalTime, windowCenter);

        if (vectorDist < shortestWait) {
          shortestWait = vectorDist;
          bestWindow = window;
        }
      }

      return {
        optimal: bestWindow,
        optimalWait: shortestWait,
        naive: naiveChoice,
        naiveWait: naiveWait,
        differentChoice: bestWindow.name !== naiveChoice.name,
      };
    }

    // Draw photo windows on clock
    function drawPhotoWindows(svg) {
      const windows = svg.querySelector(".photo-windows");
      windows.innerHTML = "";

      // Morning window arc
      const morningStart = (MORNING_START * 360) / 24 - 90;
      const morningEnd = (MORNING_END * 360) / 24 - 90;
      const morningArc = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "path"
      );
      const morningPath = describeArc(100, 100, 80, morningStart, morningEnd);
      morningArc.setAttribute("d", morningPath);
      morningArc.setAttribute("fill", "none");
      morningArc.setAttribute("stroke", "#FF9800");
      morningArc.setAttribute("stroke-width", "8");
      morningArc.setAttribute("opacity", "0.4");
      windows.appendChild(morningArc);

      // Afternoon window arc
      const afternoonStart = (AFTERNOON_START * 360) / 24 - 90;
      const afternoonEnd = (AFTERNOON_END * 360) / 24 - 90;
      const afternoonArc = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "path"
      );
      const afternoonPath = describeArc(
        100,
        100,
        80,
        afternoonStart,
        afternoonEnd
      );
      afternoonArc.setAttribute("d", afternoonPath);
      afternoonArc.setAttribute("fill", "none");
      afternoonArc.setAttribute("stroke", "#2196F3");
      afternoonArc.setAttribute("stroke-width", "8");
      afternoonArc.setAttribute("opacity", "0.4");
      windows.appendChild(afternoonArc);
    }

    // Helper to create SVG arc path
    function describeArc(x, y, radius, startAngle, endAngle) {
      const start = polarToCartesian(x, y, radius, endAngle);
      const end = polarToCartesian(x, y, radius, startAngle);
      const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
      return [
        "M",
        start.x,
        start.y,
        "A",
        radius,
        radius,
        0,
        largeArcFlag,
        0,
        end.x,
        end.y,
      ].join(" ");
    }

    function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
      const angleInRadians = (angleInDegrees * Math.PI) / 180;
      return {
        x: centerX + radius * Math.cos(angleInRadians),
        y: centerY + radius * Math.sin(angleInRadians),
      };
    }

    // Draw vector space visualization
    function drawVectorSpace() {
      const centerX = 200;
      const centerY = 200;
      const radius = 150;

      // Draw photo window sectors in vector space
      const morningStartVec = embedTimeAsVector(MORNING_START);
      const morningEndVec = embedTimeAsVector(MORNING_END);
      const morningArc = document.getElementById("morning-arc");

      const morningPath = [
        "M",
        centerX,
        centerY,
        "L",
        centerX + morningStartVec.x * radius,
        centerY + morningStartVec.y * radius,
        "A",
        radius,
        radius,
        0,
        0,
        1,  // Changed sweep-flag from 0 to 1 for clockwise
        centerX + morningEndVec.x * radius,
        centerY + morningEndVec.y * radius,
        "Z",
      ].join(" ");
      morningArc.setAttribute("d", morningPath);

      const afternoonStartVec = embedTimeAsVector(AFTERNOON_START);
      const afternoonEndVec = embedTimeAsVector(AFTERNOON_END);
      const afternoonArc = document.getElementById("afternoon-arc");

      const afternoonPath = [
        "M",
        centerX,
        centerY,
        "L",
        centerX + afternoonStartVec.x * radius,
        centerY + afternoonStartVec.y * radius,
        "A",
        radius,
        radius,
        0,
        0,
        1,  // Changed sweep-flag from 0 to 1 for clockwise
        centerX + afternoonEndVec.x * radius,
        centerY + afternoonEndVec.y * radius,
        "Z",
      ].join(" ");
      afternoonArc.setAttribute("d", afternoonPath);

      // Position labels at the center of each pie slice
      const morningCenter = (MORNING_START + MORNING_END) / 2;
      const afternoonCenter = (AFTERNOON_START + AFTERNOON_END) / 2;

      const morningCenterVec = embedTimeAsVector(morningCenter);
      const afternoonCenterVec = embedTimeAsVector(afternoonCenter);

      // Position labels at 100px radius from center (closer than the 150px arc)
      const morningLabel = document.getElementById("morning-label");
      const afternoonLabel = document.getElementById("afternoon-label");

      if (morningLabel) {
        morningLabel.setAttribute("x", centerX + morningCenterVec.x * 100);
        morningLabel.setAttribute("y", centerY + morningCenterVec.y * 100 + 4); // +4 for text baseline
      }

      if (afternoonLabel) {
        afternoonLabel.setAttribute("x", centerX + afternoonCenterVec.x * 100);
        afternoonLabel.setAttribute("y", centerY + afternoonCenterVec.y * 100 + 4); // +4 for text baseline
      }
    }

    // Update visualization
    function update() {
      const departureHours = parseFloat(departureSlider.value);
      const flightDuration = parseFloat(durationSlider.value);
      const timezoneCrossed = parseFloat(timezonesSlider.value);

      // Calculate arrival time (with timezone change)
      const arrivalHours =
        (departureHours + flightDuration + timezoneCrossed + 24) % 24;

      // Update displays
      const formatTime = (h) => {
        const hours = Math.floor(h);
        const minutes = Math.round((h - hours) * 60);
        return `${hours.toString().padStart(2, "0")}:${minutes
          .toString()
          .padStart(2, "0")}`;
      };

      departureValue.textContent = formatTime(departureHours);
      durationValue.textContent = `${flightDuration.toFixed(1)}h`;
      timezoneValue.textContent =
        timezoneCrossed > 0 ? `+${timezoneCrossed}h` : `${timezoneCrossed}h`;

      // Update clock hands
      const depAngle = (departureHours * 360) / 24 - 90;
      const arrAngle = (arrivalHours * 360) / 24 - 90;

      depHand.setAttribute(
        "x2",
        100 + 70 * Math.cos((depAngle * Math.PI) / 180)
      );
      depHand.setAttribute(
        "y2",
        100 + 70 * Math.sin((depAngle * Math.PI) / 180)
      );

      arrHand.setAttribute(
        "x2",
        100 + 70 * Math.cos((arrAngle * Math.PI) / 180)
      );
      arrHand.setAttribute(
        "y2",
        100 + 70 * Math.sin((arrAngle * Math.PI) / 180)
      );

      // VECTOR EMBEDDING
      const depVec = embedTimeAsVector(departureHours);
      const arrVec = embedTimeAsVector(arrivalHours);

      // Update vector visualization with new dimensions
      const centerX = 200;
      const centerY = 200;
      const radius = 150;

      const depX = centerX + depVec.x * radius;
      const depY = centerY + depVec.y * radius;
      const arrX = centerX + arrVec.x * radius;
      const arrY = centerY + arrVec.y * radius;

      depVector.setAttribute("x2", depX);
      depVector.setAttribute("y2", depY);
      depPoint.setAttribute("cx", depX);
      depPoint.setAttribute("cy", depY);
      depLabel.setAttribute("x", depX);
      depLabel.setAttribute("y", depY - 10);

      arrVector.setAttribute("x2", arrX);
      arrVector.setAttribute("y2", arrY);
      arrPoint.setAttribute("cx", arrX);
      arrPoint.setAttribute("cy", arrY);
      arrLabel.setAttribute("x", arrX);
      arrLabel.setAttribute("y", arrY - 10);

      // Draw arc between vectors
      // Calculate the angular difference to determine the shorter path
      let angularDiff = arrivalHours - departureHours;

      // Normalize to [-12, 12] range to find shorter path
      if (angularDiff > 12) {
        angularDiff -= 24;
      } else if (angularDiff < -12) {
        angularDiff += 24;
      }

      // For the arc to follow the circle:
      // - largeArcFlag: 0 if angular distance < 12 hours (180¬∞), 1 if >= 12 hours
      // - sweepFlag: 1 if going clockwise (positive angular difference), 0 if counter-clockwise
      const largeArcFlag = Math.abs(angularDiff) >= 12 ? 1 : 0;
      const sweepFlag = angularDiff >= 0 ? 1 : 0;

      const arcPath = [
        "M",
        depX,
        depY,
        "A",
        radius,
        radius,
        0,
        largeArcFlag,
        sweepFlag,
        arrX,
        arrY,
      ].join(" ");
      distanceArc.setAttribute("d", arcPath);

      // THIS IS THE KEY COMPARISON!
      const windowAnalysis = findOptimalWindow(arrivalHours);

      // Show pedagogical explanation when methods disagree
      if (
        windowAnalysis.differentChoice ||
        Math.abs(windowAnalysis.naiveWait - windowAnalysis.optimalWait) > 2
      ) {
        // Methods disagree significantly - explain why!
        methodDifference.style.display = "block";

        const formatTime = (h) => {
          const hours = Math.floor(h);
          const minutes = Math.round((h - hours) * 60);
          return `${hours.toString().padStart(2, "0")}:${minutes
            .toString()
            .padStart(2, "0")}`;
        };

        differenceExplanation.innerHTML = `
          <strong>Arrival time: ${formatTime(arrivalHours)}<\/strong><br>
          <strong>Naive method:<\/strong> Looks forward chronologically and says "wait ${windowAnalysis.naiveWait.toFixed(
            1
          )} hours until ${windowAnalysis.naive.name} window"<br>
          <strong>Vector method:<\/strong> Checks ALL directions on the clock and finds "${
            windowAnalysis.optimal.name
          } window is only ${windowAnalysis.optimalWait.toFixed(
          1
        )} hours away"<br>
          <br>
          <strong>Why it breaks:<\/strong> The naive method doesn't understand that time is circular! 
          It treats 23:00 and 01:00 as 22 hours apart instead of just 2 hours. 
          Vector embedding treats time as a circle where midnight connects back to itself.
        `;

        explanationText.textContent =
          "‚ö†Ô∏è The methods disagree! See explanation below.";
      } else {
        methodDifference.style.display = "none";
        explanationText.textContent =
          "Try different settings to see when naive calculation fails.";
      }

      // Show which window each approach recommends
      if (windowAnalysis.differentChoice) {
        naiveDistance.textContent = `${
          windowAnalysis.naive.name
        } (${windowAnalysis.naiveWait.toFixed(1)}h)`;
        vectorDistance.textContent = `${
          windowAnalysis.optimal.name
        } (${windowAnalysis.optimalWait.toFixed(1)}h)`;

        naiveResult.className = "result-card bad";
        vectorResult.className = "result-card good";
      } else {
        naiveDistance.textContent = `${windowAnalysis.naiveWait.toFixed(
          1
        )}h wait`;
        vectorDistance.textContent = `${windowAnalysis.optimalWait.toFixed(
          1
        )}h wait`;

        naiveResult.className =
          Math.abs(windowAnalysis.naiveWait - windowAnalysis.optimalWait) > 1
            ? "result-card bad"
            : "result-card";
        vectorResult.className = "result-card good";
      }

      // Show to nearest window
      morningDistance.textContent = `${windowAnalysis.optimalWait.toFixed(1)}h`;

      // Photo quality assessment
      let quality = "";
      let qualityClass = "";
      const inMorningWindow =
        arrivalHours >= MORNING_START && arrivalHours < MORNING_END;
      const inAfternoonWindow =
        arrivalHours >= AFTERNOON_START && arrivalHours < AFTERNOON_END;

      if (inMorningWindow || inAfternoonWindow) {
        quality = "In window! üü¢";
        qualityClass = "good";
      } else if (windowAnalysis.optimalWait < 1) {
        quality = "< 1h wait üü°";
        qualityClass = "good";
      } else if (windowAnalysis.optimalWait < 3) {
        quality = `${windowAnalysis.optimalWait.toFixed(1)}h wait üü†`;
        qualityClass = "";
      } else {
        quality = "Long wait üî¥";
        qualityClass = "bad";
      }

      photoQuality.textContent = quality;
      morningResult.className = `result-card ${
        windowAnalysis.optimalWait < 2 ? "good" : ""
      }`;
      photoReady.className = `result-card ${qualityClass}`;

      // Update distance label (now in HTML outside the SVG)
      const flightTime = circularDistance(departureHours, arrivalHours);
      if (distanceLabel) {
        distanceLabel.textContent = `Flight spans: ${flightTime.toFixed(
          1
        )}h on clock`;
      }
    }

    // Initialize photo windows
    drawPhotoWindows(depClock);
    drawPhotoWindows(arrClock);
    drawVectorSpace();

    // Event listeners
    departureSlider.addEventListener("input", update);
    durationSlider.addEventListener("input", update);
    timezonesSlider.addEventListener("input", update);

    // Toggle button for time display format
    if (timeToggle) {
      timeToggle.addEventListener("click", () => {
        isMilitaryTime = !isMilitaryTime;
        timeToggle.textContent = isMilitaryTime ? "24h" : "12h";

        // Update labels based on the time format
        if (isMilitaryTime) {
          if (labelNorth) labelNorth.textContent = "00:00";
          if (labelEast) labelEast.textContent = "06:00";
          if (labelSouth) labelSouth.textContent = "12:00";
          if (labelWest) labelWest.textContent = "18:00";
        } else {
          if (labelNorth) labelNorth.textContent = "12 AM";
          if (labelEast) labelEast.textContent = "6 AM";
          if (labelSouth) labelSouth.textContent = "12 PM";
          if (labelWest) labelWest.textContent = "6 PM";
        }
      });
    }

    // Hint button toggle
    if (hintButton) {
      hintButton.addEventListener("click", () => {
        const isHidden = hintContent.style.display === "none";
        hintContent.style.display = isHidden ? "block" : "none";
        hintButton.textContent = isHidden
          ? "üí° Hide Hint"
          : "üí° How to Break Naive Calculation";
      });
    }

    // Set initial values that show a subtle difference
    // Start with something that works, let users discover the breaking case
    departureSlider.value = "14"; // 2 PM departure
    durationSlider.value = "3"; // 3 hour flight
    timezonesSlider.value = "-1"; // Cross 1 timezone west

    // Initial update
    update();

    console.log("‚úÖ Flight Photo Window demo initialized");
  } catch (error) {
    console.error("Error initializing Flight Photo Window demo:", error);
  }
}


// GIS longitude wraparound demo for slide 12-gis-demo.html

function initGISDemo() {
    // Check if Leaflet is loaded
    if (typeof L === 'undefined') {
        console.log('Leaflet not loaded yet, retrying...');
        setTimeout(initGISDemo, 200);
        return;
    }

    // Check if map container exists
    const mapContainer = document.getElementById('map');
    if (!mapContainer) {
        console.log('Map container not found');
        return;
    }

    // Clear any existing map
    if (window.gisMap) {
        window.gisMap.remove();
        window.gisMap = null;
    }

    try {
        // International Date Line area (where the real wraparound happens)
        const DATELINE_CENTER = [0.0, 180.0]; // Equator at 180¬∞ longitude

        // Map with world copy jump disabled initially, centered on the International Date Line
        const map = L.map('map', {
            center: DATELINE_CENTER,
            zoom: 4,
            worldCopyJump: false
        });
        window.gisMap = map; // Store reference for cleanup

        // OSM tiles with attribution
        let tiles = L.tileLayer(
            'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
            {
                maxZoom: 19,
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap<\/a> contributors'
            }
        ).addTo(map);
        window.gisTiles = tiles;

        // Two draggable points that straddle the International Date Line (the REAL wraparound!)
        const blueIcon = L.divIcon({
            className: 'custom-marker',
            html: '<div style="background:#2196F3; width:20px; height:20px; border-radius:50%; border:3px solid white; box-shadow:0 2px 6px rgba(0,0,0,0.3);"><\/div>',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        });
        const orangeIcon = L.divIcon({
            className: 'custom-marker',
            html: '<div style="background:#FF9800; width:20px; height:20px; border-radius:50%; border:3px solid white; box-shadow:0 2px 6px rgba(0,0,0,0.3);"><\/div>',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        });

        const marker1 = L.marker([5.0, 175.0], {draggable:true, icon: blueIcon}).addTo(map).bindTooltip('+175¬∞E', {permanent:true, direction:'right'});
        const marker2 = L.marker([15.0, 178.0], {draggable:true, icon: orangeIcon}).addTo(map).bindTooltip('+178¬∞E', {permanent:true, direction:'left'});
        const pts = [marker1, marker2];
        window.gisMarkers = pts;

        console.log('Created GIS markers:', pts.length, 'markers at positions:',
                   pts.map(m => `${m.getLatLng().lat},${m.getLatLng().lng}`));

        // Circular mean helper function
        function meanLonDeg(ds) {
            let x = 0, y = 0;
            for (const d of ds) {
                const r = d * Math.PI / 180;
                x += Math.cos(r);
                y += Math.sin(r);
            }
            let m = Math.atan2(y, x) * 180 / Math.PI;
            if (m >= 180) m -= 360;
            if (m < -180) m += 360;
            return m;
        }

        // Result markers - RED for wrong, GREEN for correct
        const wrongMarker = L.circleMarker(DATELINE_CENTER, {
            radius: 12,
            color: '#FF1744',
            fillColor: '#FF5252',
            fillOpacity: 0.9,
            weight: 3
        }).addTo(map).bindTooltip('WRONG: Linear Mean', {permanent: false, direction: 'top'});

        const correctMarker = L.circleMarker(DATELINE_CENTER, {
            radius: 15,
            color: '#00C853',
            fillColor: '#00E676',
            fillOpacity: 0.9,
            weight: 3
        }).addTo(map).bindTooltip('CORRECT: Circular Mean', {permanent: false, direction: 'bottom'});
        const readout = document.getElementById('readout');

        window.gisResultMarkers = [wrongMarker, correctMarker];

        function update() {
            const lats = pts.map(m => m.getLatLng().lat);
            const lons = pts.map(m => m.getLatLng().lng);
            const latAvg = lats.reduce((a, b) => a + b, 0) / lats.length;
            const linMean = (lons[0] + lons[1]) / 2; // WRONG near 0¬∞
            const circMean = meanLonDeg(lons);

            wrongMarker.setLatLng([latAvg, linMean]);
            correctMarker.setLatLng([latAvg, circMean]);

            // Tiny line showing crossing at 0¬∞
            if (window.crossLine) map.removeLayer(window.crossLine);
            window.crossLine = L.polyline([[latAvg, -0.01], [latAvg, 0.01]], {color:'#4FC3F7', weight:3}).addTo(map);

            if (readout) {
                readout.textContent =
                    `Circular mean: ${circMean.toFixed(3)}¬∞, Linear mean (wrong): ${((linMean + 540) % 360 - 180).toFixed(3)}¬∞`;
            }
        }

        pts.forEach(m => m.on('drag dragend', update));
        update();

        // UI toggles
        const worldCopyCheckbox = document.getElementById('worldCopy');
        const noWrapTilesCheckbox = document.getElementById('noWrapTiles');

        if (worldCopyCheckbox) {
            worldCopyCheckbox.addEventListener('change', (e) => {
                map.options.worldCopyJump = !!e.target.checked;
                map.panBy([1, 0]); // nudge to apply visually
            });
        }

        if (noWrapTilesCheckbox) {
            noWrapTilesCheckbox.addEventListener('change', (e) => {
                const noWrap = !!e.target.checked;
                map.removeLayer(tiles);
                tiles = L.tileLayer(
                    'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                    {
                        maxZoom: 19,
                        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap<\/a> contributors',
                        noWrap
                    }
                ).addTo(map);
                window.gisTiles = tiles;
            });
        }

        console.log('GIS demo initialized');
    } catch (error) {
        console.error('Error initializing GIS demo:', error);
    }
}

function initHueDragWheel() {
  // Get reference to the SVG element
  const svg = document.getElementById("dwSVG");
  if (!svg) {
    console.error("Could not find hue drag wheel SVG element");
    return;
  }

  // Define constants for the hue wheel
  const R = 179;  // Radius corrected to visual center of the ring
  const S = 100;  // Saturation percentage for HSL colors
  const L = 50;   // Lightness percentage for HSL colors

  const lineA = svg.querySelector("#lineA");
  const lineB = svg.querySelector("#lineB");
  const lineMid = svg.querySelector("#lineMid");
  const lineNaive = svg.querySelector("#lineNaive");
  const hA = svg.querySelector("#handleA");
  const hB = svg.querySelector("#handleB");
  const hMid = svg.querySelector("#handleMid");
  const hNaive = svg.querySelector("#handleNaive");
  const labA = svg.querySelector("#labelA");
  const labB = svg.querySelector("#labelB");
  const labMid = svg.querySelector("#labelMid");
  const labNaive = svg.querySelector("#labelNaive");
  const arc = svg.querySelector("#dwArc");

  const degA = document.getElementById("degA");
  const degB = document.getElementById("degB");
  const degMid = document.getElementById("degMid");
  const degNaive = document.getElementById("degNaive");
  const dotA = document.getElementById("dotA");
  const dotB = document.getElementById("dotB");
  const dotMid = document.getElementById("dotMid");
  const dotNaive = document.getElementById("dotNaive");
  const barCircular = document.getElementById("barCircular");
  const barNaive = document.getElementById("barNaive");

  // Helpers
  const clamp360 = (h) => ((h % 360) + 360) % 360;
  const deg2rad = (d) => (d * Math.PI) / 180;
  const rad2deg = (r) => (r * 180) / Math.PI;

  // Rotated hue wheel: red at North (0¬∞), hue increases clockwise
  function posOnRing(h) {
    const a = deg2rad(h - 90); // Apply -90deg rotation
    return [200 + R * Math.cos(a), 200 + R * Math.sin(a)];
  }
  function hueFromPoint(x, y) {
    const a = Math.atan2(y - 200, x - 200);
    return clamp360(rad2deg(a) + 90); // Apply +90deg rotation
  }
  function shortestDelta(a, b) {
    return ((b - a + 540) % 360) - 180;
  } // [-180,180)
  function circularMid(h1, h2) {
    return clamp360(h1 + 0.5 * shortestDelta(h1, h2));
  }
  function naiveMid(h1, h2) {
    return clamp360((h1 + h2) / 2);
  }

  function setVector(elLine, elHandle, elLabel, hue, width = 7, dash = null) {
    const [x, y] = posOnRing(hue);
    elLine.setAttribute("x2", x);
    elLine.setAttribute("y2", y);
    // Color the line according to its hue
    elLine.setAttribute("stroke", `hsl(${hue}, ${S}%, ${L}%)`);
    elLine.setAttribute("stroke-width", width);
    if (dash) {
      elLine.setAttribute("stroke-dasharray", dash);
    } else {
      elLine.removeAttribute("stroke-dasharray");
    }
    elHandle.setAttribute("cx", x);
    elHandle.setAttribute("cy", y);
    // Color the handle with the same hue, slightly lighter
    elHandle.setAttribute(
      "fill",
      `hsl(${hue}, ${S}%, ${Math.min(70, L + 20)}%)`
    );
    // Position label slightly outside the handle
    const labelOffset = 18;
    const angle = deg2rad(hue - 90); // Apply rotation for label positioning
    elLabel.setAttribute("x", x + labelOffset * Math.cos(angle));
    elLabel.setAttribute("y", y + labelOffset * Math.sin(angle));
  }
  function setChip(dot, degree, hue) {
    dot.style.background = `hsl(${hue}, ${S}%, ${L}%)`;
    degree.textContent = `${Math.round(hue)}¬∞`;
  }
  function setArc(h1, h2) {
    const dShort = shortestDelta(h1, h2);
    // Always draw the shortest arc
    const large = Math.abs(dShort) > 180 ? 1 : 0;
    const sweepFlag = dShort > 0 ? 1 : 0; // Positive delta = clockwise sweep
    const [ax, ay] = posOnRing(h1);
    const [bx, by] = posOnRing(h2);
    arc.setAttribute(
      "d",
      `M ${ax} ${ay} A ${R} ${R} 0 ${large} ${sweepFlag} ${bx} ${by}`
    );
  }
  function setBars(h1, h2) {
    const steps = 30;
    const colsCirc = [],
      colsNaive = [];
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      const hm = clamp360(h1 + shortestDelta(h1, h2) * t);
      const hn = clamp360(h1 + (h2 - h1) * t);
      colsCirc.push(`hsl(${hm}, ${S}%, ${L}%)`);
      colsNaive.push(`hsl(${hn}, ${S}%, ${L}%)`);
    }
    barCircular.style.background = `linear-gradient(90deg, ${colsCirc.join(
      ","
    )})`;
    barNaive.style.background = `linear-gradient(90deg, ${colsNaive.join(
      ","
    )})`;
  }

  // State
  let H1 = 340, // Start with red-magenta
    H2 = 40;  // Start with orange
  function render() {
    const Hmid = circularMid(H1, H2);
    const Hnaive = naiveMid(H1, H2);
    setVector(lineA, hA, labA, H1, 7, null);
    setVector(lineB, hB, labB, H2, 7, null);
    setVector(lineMid, hMid, labMid, Hmid, 7, null);
    setVector(lineNaive, hNaive, labNaive, Hnaive, 5, "4,6");
    setChip(dotA, degA, H1);
    setChip(dotB, degB, H2);
    setChip(dotMid, degMid, Hmid);
    setChip(dotNaive, degNaive, Hnaive);
    setArc(H1, H2);
    setBars(H1, H2);
  }

  // Dragging
  function makeDraggable(handle, which) {
    let dragging = false;
    function onDown(e) {
      dragging = true;
      e.preventDefault();
      handle.setPointerCapture?.(e.pointerId);
    }
    function onMove(e) {
      if (!dragging) return;
      const r = svg.getBoundingClientRect();
      const x = e.clientX - r.left,
        y = e.clientY - r.top;
      const hue = hueFromPoint(x, y);
      if (which === "A") H1 = hue;
      else H2 = hue;
      render();
    }
    function onUp(e) {
      dragging = false;
      handle.releasePointerCapture?.(e.pointerId);
    }
    handle.addEventListener("pointerdown", onDown);
    window.addEventListener("pointermove", onMove);
    window.addEventListener("pointerup", onUp);
  }
  makeDraggable(hA, "A");
  makeDraggable(hB, "B");

  // Click on ring to set nearest handle
  svg.addEventListener("pointerdown", (e) => {
    const r = svg.getBoundingClientRect();
    const x = e.clientX - r.left,
      y = e.clientY - r.top;
    const hue = hueFromPoint(x, y);
    const dA = Math.abs(shortestDelta(hue, H1)),
      dB = Math.abs(shortestDelta(hue, H2));
    if (dA <= dB) H1 = hue;
    else H2 = hue;
    render();
  });

  render();
}


// Interactive angle averaging demo for slide 11-interactive-demo.html

function initInteractiveDemo() {
    const angle1Input = document.getElementById('angle1');
    const angle2Input = document.getElementById('angle2');
    const angle1Display = document.getElementById('angle1-display');
    const angle2Display = document.getElementById('angle2-display');
    const wrongResult = document.getElementById('wrong-result');
    const correctResult = document.getElementById('correct-result');

    // Check if elements exist (safety check)
    if (!angle1Input || !angle2Input) {
        console.log('Interactive demo elements not found');
        return;
    }

    function updateDemo() {
        const a1 = parseInt(angle1Input.value);
        const a2 = parseInt(angle2Input.value);

        // Update displays
        angle1Display.textContent = a1 + '¬∞';
        angle2Display.textContent = a2 + '¬∞';

        // Calculate wrong (linear) average
        const wrongAvg = (a1 + a2) / 2;
        wrongResult.textContent = Math.round(wrongAvg) + '¬∞';

        // Calculate correct (circular) average
        const theta1 = a1 * Math.PI / 180;
        const theta2 = a2 * Math.PI / 180;
        const v1 = [Math.cos(theta1), Math.sin(theta1)];
        const v2 = [Math.cos(theta2), Math.sin(theta2)];
        const avgVec = [(v1[0] + v2[0])/2, (v1[1] + v2[1])/2];
        const norm = Math.sqrt(avgVec[0]**2 + avgVec[1]**2);
        avgVec[0] /= norm; avgVec[1] /= norm;
        const correctAvg = Math.atan2(avgVec[1], avgVec[0]) * 180 / Math.PI;
        const correctAvgNormalized = (correctAvg + 360) % 360;
        correctResult.textContent = Math.round(correctAvgNormalized) + '¬∞';

        // Update visual
        updateVisual(a1, a2, wrongAvg, correctAvgNormalized);

        // Show/hide wrong result based on how wrong it is
        const wrongness = Math.abs(wrongAvg - correctAvgNormalized);
        const adjustedWrongness = Math.min(wrongness, 360 - wrongness);
        const opacity = adjustedWrongness > 30 ? 1 : 0;

        const wrongLine = document.getElementById('avg-wrong-line');
        const wrongPoint = document.getElementById('avg-wrong-point');
        if (wrongLine) wrongLine.style.opacity = opacity;
        if (wrongPoint) wrongPoint.style.opacity = opacity;
    }

    function updateVisual(a1, a2, wrongAvg, correctAvg) {
        const cx = 200, cy = 200, r = 150;

        // Convert angles to positions
        function angleToPos(angle) {
            const rad = (angle - 90) * Math.PI / 180; // -90 to start from top
            return {
                x: cx + r * Math.cos(rad),
                y: cy + r * Math.sin(rad)
            };
        }

        const pos1 = angleToPos(a1);
        const pos2 = angleToPos(a2);
        const wrongPos = angleToPos(wrongAvg);
        const correctPos = angleToPos(correctAvg);

        // Update lines and points safely
        const elements = [
            { id: 'angle1-line', x2: pos1.x, y2: pos1.y },
            { id: 'angle1-point', cx: pos1.x, cy: pos1.y },
            { id: 'angle2-line', x2: pos2.x, y2: pos2.y },
            { id: 'angle2-point', cx: pos2.x, cy: pos2.y },
            { id: 'avg-wrong-line', x2: wrongPos.x, y2: wrongPos.y },
            { id: 'avg-wrong-point', cx: wrongPos.x, cy: wrongPos.y },
            { id: 'avg-correct-line', x2: correctPos.x, y2: correctPos.y },
            { id: 'avg-correct-point', cx: correctPos.x, cy: correctPos.y }
        ];

        elements.forEach(elem => {
            const element = document.getElementById(elem.id);
            if (element) {
                if (elem.x2 !== undefined) element.setAttribute('x2', elem.x2);
                if (elem.y2 !== undefined) element.setAttribute('y2', elem.y2);
                if (elem.cx !== undefined) element.setAttribute('cx', elem.cx);
                if (elem.cy !== undefined) element.setAttribute('cy', elem.cy);
            }
        });
    }

    // Set up event listeners
    angle1Input.addEventListener('input', updateDemo);
    angle2Input.addEventListener('input', updateDemo);

    // Initial update
    updateDemo();

    console.log('Interactive demo initialized');
}

let currentSlide = 0;

function showSlide(index) {
    if (index < 0 || index >= slidesData.length) return;

    console.log(`${'='.repeat(80)}`);
    console.log(`üé¨ LOADING SLIDE ${index + 1}/${slidesData.length}: ${slidesData[index].title || `slide-${index}`}`);
    console.log(`   Title: ${slidesData[index].title || 'Untitled'}`);
    console.log(`${'='.repeat(80)}`);

    const slideContent = document.getElementById('slide-content');
    slideContent.innerHTML = slidesData[index].content;
    
    // Update counter
    document.getElementById('current-slide').textContent = index + 1;
    document.getElementById('total-slides').textContent = slidesData.length;
    
    // Update navigation buttons (allow wrap-around, so no disabling)
    const prevButton = document.querySelector('.nav-button');
    const nextButton = document.querySelector('.nav-button:last-child');
    
    // Add fade in animation
    slideContent.style.animation = 'none';
    slideContent.offsetHeight; // Trigger reflow
    slideContent.style.animation = 'fadeIn 0.5s';
    
    // Re-run any scripts in the slide
    const scripts = slideContent.querySelectorAll('script');
    scripts.forEach(script => {
        try {
            const newScript = document.createElement('script');
            if (script.src) {
                newScript.src = script.src;
            } else {
                newScript.textContent = script.textContent;
            }
            script.parentNode.replaceChild(newScript, script);
        } catch (error) {
            console.warn('Error re-executing script:', error);
            // Try alternative approach - evaluate script directly
            try {
                eval(script.textContent);
            } catch (evalError) {
                console.error('Failed to execute script:', evalError);
            }
        }
    });

    // Fire the slideLoaded event to trigger SVG enhancement pipeline
    window.dispatchEvent(new Event('slideLoaded'));

    // Initialize interactive demos if present
    // Check for hue drag wheel (slide 06)
    if (document.getElementById('dwSVG') && typeof initHueDragWheel === 'function') {
        console.log('üé® Initializing hue drag wheel for slide', index + 1);
        initHueDragWheel();
    }

    // Check for vector calculator
    if (document.getElementById('vector-demo') && typeof initVectorCalculator === 'function') {
        console.log('üìê Initializing vector calculator for slide', index + 1);
        initVectorCalculator();
    }

    // Check for timeseries analyzer
    if (document.getElementById('timeseries-demo') && typeof initTimeseriesAnalyzer === 'function') {
        console.log('üìà Initializing timeseries analyzer for slide', index + 1);
        initTimeseriesAnalyzer();
    }

    // Check for interactive angle demo
    if (document.getElementById('angle1') && typeof initInteractiveDemo === 'function') {
        console.log('üéÆ Initializing interactive angle demo for slide', index + 1);
        initInteractiveDemo();
    }

    // Check for GIS demo
    if (document.getElementById('map') && typeof initGISDemo === 'function') {
        console.log('üó∫Ô∏è Initializing GIS demo for slide', index + 1);
        initGISDemo();
    }

    // Check for flight photo window demo
    if (document.getElementById('departure-time') && typeof initFlightPhotoWindow === 'function') {
        console.log('üì∏ Initializing flight photo window demo for slide', index + 1);
        initFlightPhotoWindow();
    }

    // Check for flight vs now timezone demo (more specific check)
    if (document.getElementById('syd-date') &&
        document.getElementById('utc-timeline') &&
        typeof initFlightVsNow === 'function') {
        console.log('üõ©Ô∏è Initializing flight vs now timezone demo for slide', index + 1);
        initFlightVsNow();
    }

    currentSlide = index;
}

function nextSlide() {
    if (currentSlide < slidesData.length - 1) {
        currentSlide++;
        showSlide(currentSlide);
    } else {
        // Wrap to the first slide
        currentSlide = 0;
        showSlide(currentSlide);
    }
}

function previousSlide() {
    console.log('üîÑ previousSlide() called - currentSlide:', currentSlide, 'totalSlides:', slidesData.length);

    if (currentSlide > 0) {
        currentSlide--;
        console.log('   Moving to previous slide:', currentSlide);
        showSlide(currentSlide);
    } else {
        // Wrap to the last slide
        currentSlide = slidesData.length - 1;
        console.log('   Wrapping to last slide:', currentSlide);
        showSlide(currentSlide);
    }
}

function goToSlide(index) {
    if (index >= 0 && index < slidesData.length) {
        currentSlide = index;
        showSlide(currentSlide);
    }
}

// Keyboard navigation
document.addEventListener('keydown', function(event) {
    if (event.key === 'ArrowRight' || event.key === ' ') {
        event.preventDefault();
        nextSlide();
    } else if (event.key === 'ArrowLeft') {
        event.preventDefault();
        previousSlide();
    } else if (event.key >= '1' && event.key <= '9') {
        const slideNum = parseInt(event.key) - 1;
        if (slideNum < slidesData.length) {
            goToSlide(slideNum);
        }
    } else if (event.key === 'Home') {
        goToSlide(0);
    } else if (event.key === 'End') {
        goToSlide(slidesData.length - 1);
    }
});

// Initialize on first load
document.addEventListener('DOMContentLoaded', function() {
    showSlide(0);
});

    </script>
</body>
</html>
